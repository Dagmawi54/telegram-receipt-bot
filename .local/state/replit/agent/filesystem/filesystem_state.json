{"file_contents":{"replit.md":{"content":"# Overview\n\nThis is a Telegram bot designed to process payment receipts for an apartment complex. The bot extracts transaction details from receipt images using OCR, validates payment information, and stores records in Google Sheets. It supports multi-group deployment, beneficiary validation, and includes features like message editing, auto-deletion, and Ethiopian calendar conversion.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Bot Framework & Communication\n- **Technology**: Python Telegram Bot library (v21.7)\n- **Communication Pattern**: Asynchronous message handling with webhook or polling\n- **Message Processing**: \n  - Tracks processed message IDs to prevent duplicate processing during offline periods\n  - Supports buffered message processing when bot comes back online\n  - Auto-deletes success messages after 10 minutes and error messages after 3 minutes\n\n## Multi-Group Support\n- **Design Pattern**: Configuration-based multi-tenancy\n- **Configuration File**: `groups.json` - Maps Telegram group IDs to their respective configurations\n- **Group Isolation**: Each group has:\n  - Its own Google Sheets spreadsheet\n  - Specific topic/thread ID for responses\n  - Admin user list for privileged operations\n  - Custom house number mapping file\n- **Rationale**: Allows single bot instance to serve multiple apartment complexes without data mixing\n\n## OCR & Data Extraction\n- **Technology**: Tesseract OCR via pytesseract library\n- **Image Processing**: Pillow (PIL) for image manipulation\n- **Extraction Features**:\n  - Transaction IDs (with/without colon format)\n  - Payment amounts (VAT-free extraction)\n  - Payment dates (with Gregorian to Ethiopian calendar conversion)\n  - Beneficiary/receiver names from receipts\n  - Payment reasons (displayed in Amharic)\n  - House numbers (3-4 digit format)\n\n## Beneficiary Validation\n- **Purpose**: Prevents saving receipts sent to incorrect accounts\n- **Expected Accounts**: SEYOUM ASSEFA and/or SENAIT DAGNIE\n- **Validation Flow**:\n  1. Extract beneficiary name from receipt OCR\n  2. Compare against expected account names\n  3. Block save operation if mismatch detected\n  4. Display clear error message with account details\n  \n## Edit Mode System\n- **User-Specific Editing**: Each user can enter edit mode independently via `/edit` command or Edit button\n- **Extended Timeout**: 60 seconds for edit mode vs 30 seconds for normal processing\n- **Thread Isolation**: Edit timeout notifications sent only to correct topic/thread\n- **Prevention Logic**: Smart sheet updates prevent duplicate entries\n- **Message Deletion Detection**: Bot checks if user deleted message during buffer window and aborts processing if so\n\n## DM Support & Admin Features\n- **/start Command**: Professional popup asking user to select Admin or User access\n  - **Admin Access**: Shows admin panel if user is admin, access denied otherwise\n  - **User Access**: Shows bot info and how to use instructions with user ID\n  - **Navigation**: Back to Start button on all panels for easy navigation\n- **Admin Panel in DMs**: Admins can access panel via /admin command or /start button\n- **Multi-Group Selection**: Admins of multiple groups can select which group to manage\n- **Excel Download**: Admins can download payment data as Excel file from admin panel\n- **Payment History Button**: Users see \"·â≥·à™·ä≠\" (History) button after successful payment\n  - **DM Redirect**: History is sent privately to user's DM, not shown in group\n  - **Sender-Only Access**: Only the original message sender can view their history\n  - **Access Denied**: Unauthorized users receive error in their DM (not the group)\n- **Professional Menu Layout**: Admin menu uses horizontal 2-button layout per row for cleaner interface\n- **Admin Contact**: All error messages reference @sphinxlike for support\n\n## Duplicate Transaction ID Prevention\n- **Validation**: Receipts with already-used transaction IDs are rejected\n- **Comma-Separated Handling**: Checks TXIDs within comma-separated lists (e.g., \"ABC123, XYZ456\")\n- **Cross-Sheet Check**: Validates across all payment sheets (water, electricity, penalty, etc.)\n- **User Feedback**: Clear error message with location of duplicate entry\n\n## Data Storage\n- **Primary Storage**: Google Sheets via gspread library\n- **Authentication**: Service account credentials (`credentials.json`)\n- **Local Storage**:\n  - `processed_messages.json`: Tracks processed message IDs for offline resilience\n  - `houses.json`: Maps house numbers to resident names (Amharic)\n  - `groups.json`: Group configuration database\n\n## Calendar System\n- **Conversion Library**: convertdate\n- **Purpose**: Converts Gregorian dates to Ethiopian calendar for local context\n- **Integration**: Automatic conversion during receipt processing\n\n## Localization\n- **Language**: Amharic support for payment reasons and house names\n- **Display**: Payment reasons shown in Amharic (·ãç·àÉ, ·ä§·àå·ä≠·âµ·à™·ä≠, ·âÖ·å£·âµ, etc.)\n- **House Mappings**: Resident names stored in Amharic characters\n\n# External Dependencies\n\n## Third-Party Services\n- **Telegram Bot API**: Core bot functionality and message handling\n- **Hugging Face API**: Token included in `token.txt` (purpose: possibly AI/ML features - token present but usage unclear from main code)\n\n## Google Services\n- **Google Sheets API**: \n  - Data persistence layer\n  - Accessed via service account authentication\n  - Project ID: `stone-bindery-477314-t2`\n  - Service account: `pbt-409@stone-bindery-477314-t2.iam.gserviceaccount.com`\n\n## Python Libraries\n- **python-telegram-bot** (21.7): Telegram bot framework\n- **gspread** (5.11.3): Google Sheets integration\n- **google-auth** (2.22.0): Google API authentication\n- **oauth2client** (4.1.3): OAuth2 authentication flow\n- **pytesseract** (0.3.10): OCR text extraction\n- **Pillow** (10.0.1): Image processing\n- **convertdate**: Calendar conversion utilities\n- **pandas**: Data manipulation\n- **openpyxl**: Excel file handling\n- **requests** (2.31.0): HTTP requests\n\n## System Dependencies\n- **Tesseract OCR**: Required system package for pytesseract (not in requirements.txt but needed for OCR functionality)","path":null,"size_bytes":6175,"size_tokens":null},"pyproject.toml":{"content":"[project]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\nrequires-python = \">=3.11\"\ndependencies = []\n","path":null,"size_bytes":157,"size_tokens":null},"better1.py":{"content":"\"\"\"\nVERSION 21 - BENEFICIARY VALIDATION\n\nNEW FEATURES IN V21:\n1. Beneficiary/Receiver Validation:\n   ‚úì Extracts beneficiary name from receipts (who received the payment)\n   ‚úì Validates against expected accounts (SEYOUM ASSEFA and/or SENAIT DAGNIE)\n   ‚úì Blocks saving if payment sent to wrong account\n   ‚úì Shows clear error message with account name mismatch\n   ‚úì Auto-deletes error messages after 3 minutes\n\nPREVIOUS FEATURES (V20):\n1. Amharic Payment Reason Display:\n   ‚úì Payment reasons now shown in Amharic (·ãç·àÉ, ·ä§·àå·ä≠·âµ·à™·ä≠, ·âÖ·å£·âµ, etc.)\n   ‚úì Consistent Amharic display across all user-facing messages\n   \n2. Message Tracking (Offline Support):\n   ‚úì Tracks processed message IDs to avoid re-analyzing messages\n   ‚úì When bot comes back online after downtime, only processes new messages\n   ‚úì Prevents duplicate processing of messages sent while bot was offline\n   \n3. Fixed Thread ID Issue:\n   ‚úì 60-second edit mode timeout notification now only sent to correct thread\n   ‚úì No more timeout messages appearing in general/wrong topics\n   \n4. Multi-Group Support (Infrastructure):\n   ‚úì Bot can be configured to work with multiple Telegram groups\n   ‚úì Each group can have its own spreadsheet and topic ID\n   ‚úì To add a new group, add entry to GROUP_CONFIGS dictionary\n\n5. Auto-Delete Messages:\n   ‚úì Success/recorded data messages disappear after 10 minutes (600s)\n   ‚úì Error messages disappear after 3 minutes (180s)\n\nPREVIOUS FEATURES (V19):\n- Full Message Edit Mode\n- Extended Edit Timeout (60s for edit, 25s for normal)\n- Smart Sheet Updates (no duplicate entries)\n- User-specific Edit Mode (/edit command + Edit button)\n- Multi-User Isolation\n- Transaction ID Extraction (with/without colon)\n- Caption Month Extraction (user text ‚Üí caption ‚Üí OCR priority)\n- VAT-Free Amount Extraction\n- Flexible House Number Input (3-4 digits)\n- Gregorian to Ethiopian calendar conversion\n\"\"\"\n\nimport re\nimport json\nimport logging\nimport asyncio\nfrom datetime import datetime\nfrom collections import defaultdict\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import Application, MessageHandler, CommandHandler, CallbackQueryHandler, filters, ContextTypes\nfrom telegram.error import BadRequest\nimport gspread\nfrom oauth2client.service_account import ServiceAccountCredentials\nfrom google.oauth2 import service_account\nimport requests\n\n# ========== CONFIGURATION ==========\nimport os\n\n# ========== LOGGING (must be initialized early) ==========\nlogging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',\n                    level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# CRITICAL: Set BOT_TOKEN environment variable before running\n# The previous token has been exposed in version control and should be rotated\n# Get a new token from @BotFather on Telegram and set it as an environment variable:\n#   export BOT_TOKEN=\"your_new_bot_token_here\"\n# Or temporarily replace YOUR_BOT_TOKEN_HERE below for testing\nBOT_TOKEN = os.getenv('BOT_TOKEN', \"YOUR_BOT_TOKEN_HERE\")\n\n# ========== MULTI-GROUP CONFIGURATION LOADER ==========\ndef load_group_configs():\n    \"\"\"Load multi-group configuration from groups.json\"\"\"\n    groups_file = \"groups.json\"\n    \n    # Try to load from groups.json\n    try:\n        with open(groups_file, 'r', encoding='utf-8') as f:\n            config_data = json.load(f)\n            groups = config_data.get('groups', {})\n            \n            # Convert string chat_ids to integers\n            group_configs = {}\n            for chat_id_str, group_data in groups.items():\n                # Skip instruction entries\n                if chat_id_str.startswith('_') or chat_id_str.startswith('EXAMPLE'):\n                    continue\n                    \n                try:\n                    chat_id = int(chat_id_str)\n                    group_configs[chat_id] = group_data\n                except ValueError:\n                    logger.warning(f\"‚ö†Ô∏è Invalid chat_id in groups.json: {chat_id_str} (must be numeric)\")\n                    \n            if not group_configs:\n                logger.warning(f\"‚ö†Ô∏è No valid groups found in {groups_file}, using fallback configuration\")\n                return None\n                \n            logger.info(f\"‚úì Loaded {len(group_configs)} group(s) from {groups_file}\")\n            return group_configs\n            \n    except FileNotFoundError:\n        logger.warning(f\"‚ö†Ô∏è {groups_file} not found, using environment variable fallback\")\n        return None\n    except json.JSONDecodeError as e:\n        logger.error(f\"‚ùå Invalid JSON in {groups_file}: {e}\")\n        return None\n\n# Load group configs from file or use fallback\nGROUP_CONFIGS = load_group_configs()\n\n# Fallback to environment variables if groups.json not configured\nif GROUP_CONFIGS is None:\n    logger.info(\"Using fallback configuration from environment variables\")\n    SPREADSHEET_ID = os.getenv('SPREADSHEET_ID', \"1MlAyMsDRX1sZn23KqDztuPaG4hLuUC4CsFUmjU_Mm3I\")\n    TOPIC_ID = int(os.getenv('TOPIC_ID', 154))\n    ADMIN_USER_IDS_STR = os.getenv('ADMIN_USER_IDS', '638333361,1190394636,6513030907')\n    ADMIN_USER_IDS = [int(uid.strip()) for uid in ADMIN_USER_IDS_STR.split(',') if uid.strip()]\n    \n    # Create single-group config for backward compatibility\n    DEFAULT_CHAT_ID = int(os.getenv('DEFAULT_CHAT_ID', '-1003290908954'))\n    GROUP_CONFIGS = {\n        DEFAULT_CHAT_ID: {\n            'name': 'Default Group',\n            'spreadsheet_id': SPREADSHEET_ID,\n            'topic_id': TOPIC_ID,\n            'houses_file': 'houses.json',\n            'admin_user_ids': ADMIN_USER_IDS\n        }\n    }\n    \nDEFAULT_GROUP_ID = list(GROUP_CONFIGS.keys())[0]\n\nCREDENTIALS_FILE = \"credentials.json\"\n\nOCR_API_URL = \"https://api.ocr.space/parse/image\"\nOCR_API_KEY = os.getenv('OCR_API_KEY', \"helloworld\")\n\nPROCESSED_MESSAGES_FILE = \"processed_messages.json\"\n\n# ========== BENEFICIARY VALIDATION ==========\n# Expected account names for payment validation (requires full first+last name match)\nVALID_BENEFICIARIES = [\n    \"SEYOUM ASSEFA\",\n    \"SENAIT DAGNIE\",\n    \"SEYOUM ASSEFA AND SENAIT DAGNIE\",\n    \"SEYOUM ASSEFA OR SENAIT DAGNIE\",\n    \"ASSEFA SEYOUM\",  # Reversed order variant\n    \"DAGNIE SENAIT\"   # Reversed order variant\n]\n\n# ========== PER-GROUP STATE MANAGEMENT ==========\n# Message buffering (wait 30 seconds to collect multiple messages from same user)\nMESSAGE_BUFFER_DELAY = 30  # seconds\nEDIT_MODE_DELAY = 60  # seconds - longer timeout for edit mode\n\n# All state is now partitioned by (chat_id, user_id) for multi-group isolation\n# Using nested defaultdict: {chat_id: {user_id: ...}}\ndef nested_defaultdict():\n    return defaultdict(list)\n\nuser_message_buffers = defaultdict(nested_defaultdict)  # {chat_id: {user_id: [messages]}}\nuser_buffer_tasks = defaultdict(dict)  # {chat_id: {user_id: asyncio.Task}}\n\n# Track last submissions for edit mode (group-specific, user-specific)\nuser_last_submissions = defaultdict(dict)  # {chat_id: {user_id: {'data': {...}, 'sheet_name': '...', ...}}}\n\n# Track which users are in edit mode (per group)\nuser_edit_mode = defaultdict(dict)  # {chat_id: {user_id: True/False}}\nuser_edit_mode_tasks = defaultdict(dict)  # {chat_id: {user_id: asyncio.Task}}\n\n# Track which admins are in search mode (per group)\nadmin_search_mode = defaultdict(dict)  # {chat_id: {user_id: True/False}}\n\n# Track processed messages (to avoid re-analyzing messages when bot was offline)\n# Uses composite keys (chat_id, message_id, thread_id) to support multi-group\nprocessed_message_ids = set()  # Set of tuples: (chat_id, message_id, thread_id)\n\n# ========== PAYMENT REASONS ==========\nPAYMENT_REASONS = {\n    'water': ['·ãç·àÉ', 'water', 'wuha', 'weha', '·ã®·ãç·àÄ', '·ãç·àÄ', 'wiha', '·ã®·ãç·àÉ', '·ã®·ãç·àÄ ·ä≠·çç·ã´', '·ã®·ãç·àÉ ·ä≠·çç·ã´', 'wha', '·ãç·äÉ', \n              '·ã®·ãâ·àÉ', '·ãâ·àÉ', '·ã®·ãâ·àÄ', '·ãâ·àÄ', '·ã®·ãâ·àÉ ·ä≠·çç·ã´', '·ãâ·äÉ', '·ã®·ãâ·äÉ'],  # Added variations with ·ãâ character\n    'electricity': ['·ä§·àå·ä≠·âµ·à™·ä≠', '·ã®·àò·â•·à´·âµ', '·àô·âÄ·âµ', 'electricity', 'electric', 'power', '·àò·â•·à´·âµ'],\n    'development': ['·ã®·àç·àõ·âµ', '·àç·àõ·âµ', '·ä†·ä´·â£·â¢', '·å•·åà·äì', '·å§·äì', 'development', 'environmental', 'environment', 'maintenance', 'repair', 'health', 'medical', 'hospital', 'doctor'],\n    'penalty': ['·âÖ·å£·âµ', '·ã®·âÖ·å£·âµ', 'penalty', 'fine', 'ketat', 'ktat', 'kitat'],\n    'other': ['·ã´·àç·â≥·ãà·âÄ', 'other', 'unknown']\n}\n\n# Payment reasons in Amharic (for display)\nPAYMENT_REASONS_AMHARIC = {\n    'water': '·ãç·àÄ',\n    'electricity': '·ã®·àò·â•·à´·âµ',\n    'development': '·ã®·àç·àõ·âµ',\n    'penalty': '·ã®·âÖ·å£·âµ',\n    'other': '·ã´·àç·â≥·ãà·âÄ'\n}\n\n# ========== ETHIOPIAN CALENDAR MONTHS ==========\nETHIOPIAN_MONTHS_LIST = [\n    'Meskerem',  # 1st month\n    'Tikimt',  # 2nd month\n    'Hidar',  # 3rd month\n    'Tahsas',  # 4th month\n    'Tir',  # 5th month\n    'Yekatit',  # 6th month\n    'Megabit',  # 7th month\n    'Miyazya',  # 8th month\n    'Ginbot',  # 9th month\n    'Sene',  # 10th month\n    'Hamle',  # 11th month\n    'Nehase',  # 12th month\n    'Pagume'  # 13th month\n]\n\n# Ethiopian months in Amharic\nETHIOPIAN_MONTHS_AMHARIC = {\n    'Meskerem': '·àò·àµ·ä®·à®·àù',\n    'Tikimt': '·å•·âÖ·àù·âµ',\n    'Hidar': '·àÖ·ã≥·à≠',\n    'Tahsas': '·â≥·àÖ·à≥·àµ',\n    'Tir': '·å•·à≠',\n    'Yekatit': '·ã®·ä´·â≤·âµ',\n    'Megabit': '·àò·åã·â¢·âµ',\n    'Miyazya': '·àö·ã´·ãù·ã´',\n    'Ginbot': '·åç·äï·â¶·âµ',\n    'Sene': '·à∞·äî',\n    'Hamle': '·àê·àù·àå',\n    'Nehase': '·äê·àê·à¥',\n    'Pagume': '·å≥·åâ·àú'\n}\n\n# ========== GREGORIAN TO ETHIOPIAN CALENDAR CONVERSION ==========\n# Gregorian month ‚Üí Ethiopian month (ACTUAL conversion, not translation!)\n# Ethiopian calendar is 7-8 years behind\n# Approximate mapping (varies by exact date):\nGREGORIAN_TO_ETHIOPIAN = {\n    # Gregorian Month ‚Üí Ethiopian Month (equivalent)\n    'january': 'Tir',  # Jan ‚âà Tir (5th Ethiopian month)\n    'february': 'Yekatit',  # Feb ‚âà Yekatit (6th Ethiopian month)\n    'march': 'Megabit',  # Mar ‚âà Megabit (7th Ethiopian month)\n    'april': 'Miyazya',  # Apr ‚âà Miyazya (8th Ethiopian month)\n    'may': 'Ginbot',  # May ‚âà Ginbot (9th Ethiopian month)\n    'june': 'Sene',  # Jun ‚âà Sene (10th Ethiopian month)\n    'july': 'Hamle',  # Jul ‚âà Hamle (11th Ethiopian month)\n    'august': 'Nehase',  # Aug ‚âà Nehase (12th Ethiopian month)\n    'september': 'Pagume',  # Sep ‚âà Pagume (13th Ethiopian month)\n    'october': 'Meskerem',  # Oct ‚âà Meskerem (1st Ethiopian month)\n    'november': 'Tikimt',  # Nov ‚âà Tikimt (2nd Ethiopian month)\n    'december': 'Hidar',  # Dec ‚âà Hidar (3rd Ethiopian month)\n\n    # Shortened versions\n    'jan': 'Tir',\n    'feb': 'Yekatit',\n    'mar': 'Megabit',\n    'apr': 'Miyazya',\n    'may': 'Ginbot',\n    'jun': 'Sene',\n    'jul': 'Hamle',\n    'aug': 'Nehase',\n    'sep': 'Pagume',\n    'oct': 'Meskerem',\n    'nov': 'Tikimt',\n    'dec': 'Hidar',\n}\n\n# Ethiopian months - direct (already Ethiopian, return as is)\nfor eth_month in ETHIOPIAN_MONTHS_LIST:\n    GREGORIAN_TO_ETHIOPIAN[eth_month.lower()] = eth_month\n\n# Add alternate spellings for Ethiopian months (common user variations)\nGREGORIAN_TO_ETHIOPIAN['hedar'] = 'Hidar'  # Common misspelling of Hidar\n\n# Add Amharic month names (full and shortened versions)\nAMHARIC_TO_ETHIOPIAN = {\n    # Full Amharic names\n    '·àò·àµ·ä®·à®·àù': 'Meskerem',\n    '·ã®·àò·àµ·ä®·à®·àù': 'Meskerem',  # With ·ã® prefix (\"of\")\n    '·å•·âÖ·àù·âµ': 'Tikimt',\n    '·ã®·å•·âÖ·àù·âµ': 'Tikimt',  # With ·ã® prefix\n    '·å•·âÖ·àù': 'Tikimt',  # Shortened version\n    '·ã®·å•·âÖ·àù': 'Tikimt',  # Shortened with ·ã® prefix\n    '·àÖ·ã≥·à≠': 'Hidar',\n    '·ã®·àÖ·ã≥·à≠': 'Hidar',  # With ·ã® prefix\n    '·ã®·àï·ã≥·à≠': 'Hidar',  # Alternative spelling with ·ã® prefix\n    '·àï·ã≥·à≠': 'Hidar',  # Alternative spelling\n    '·â≥·àÖ·à≥·àµ': 'Tahsas',\n    '·ã®·â≥·àÖ·à≥·àµ': 'Tahsas',  # With ·ã® prefix\n    '·â≥·àÖ·à≥': 'Tahsas',  # Shortened\n    '·ã®·â≥·àÖ·à≥': 'Tahsas',  # Shortened with ·ã® prefix\n    '·å•·à≠': 'Tir',\n    '·ã®·å•·à≠': 'Tir',  # With ·ã® prefix\n    '·ã®·ä´·â≤·âµ': 'Yekatit',\n    '·ã®·ä´·âµ': 'Yekatit',  # Shortened\n    '·àò·åã·â¢·âµ': 'Megabit',\n    '·ã®·àò·åã·â¢·âµ': 'Megabit',  # With ·ã® prefix\n    '·àò·åã·â¢': 'Megabit',  # Shortened\n    '·ã®·àò·åã·â¢': 'Megabit',  # Shortened with ·ã® prefix\n    '·àö·ã´·ãù·ã´': 'Miyazya',\n    '·ã®·àö·ã´·ãù·ã´': 'Miyazya',  # With ·ã® prefix\n    '·àö·ã´·ãù': 'Miyazya',  # Shortened\n    '·ã®·àö·ã´·ãù': 'Miyazya',  # Shortened with ·ã® prefix\n    '·åç·äï·â¶·âµ': 'Ginbot',\n    '·ã®·åç·äï·â¶·âµ': 'Ginbot',  # With ·ã® prefix\n    '·åç·äï·â¶': 'Ginbot',  # Shortened\n    '·ã®·åç·äï·â¶': 'Ginbot',  # Shortened with ·ã® prefix\n    '·à∞·äî': 'Sene',\n    '·ã®·à∞·äî': 'Sene',  # With ·ã® prefix\n    '·àê·àù·àå': 'Hamle',\n    '·ã®·àê·àù·àå': 'Hamle',  # With ·ã® prefix\n    '·äê·àê·à¥': 'Nehase',\n    '·ã®·äê·àê·à¥': 'Nehase',  # With ·ã® prefix\n    '·å≥·åâ·àú': 'Pagume',\n    '·ã®·å≥·åâ·àú': 'Pagume',  # With ·ã® prefix\n}\n\n# Merge Amharic names into the main dictionary\nfor amharic_name, ethiopian_name in AMHARIC_TO_ETHIOPIAN.items():\n    GREGORIAN_TO_ETHIOPIAN[amharic_name] = ethiopian_name\n\n# ========== PER-GROUP RESOURCE LOADING ==========\n# Cache for per-group houses data: {chat_id: {house_num: name}}\nhouse_maps = {}\n\ndef load_houses_for_group(chat_id: int) -> dict:\n    \"\"\"Load houses data for a specific group (with caching)\"\"\"\n    if chat_id in house_maps:\n        return house_maps[chat_id]\n    \n    if chat_id not in GROUP_CONFIGS:\n        logger.warning(f\"‚ö†Ô∏è Unknown chat_id {chat_id}, cannot load houses\")\n        return {}\n    \n    houses_file = GROUP_CONFIGS[chat_id].get('houses_file', 'houses.json')\n    try:\n        with open(houses_file, 'r', encoding='utf-8') as f:\n            house_map = json.load(f)\n        house_maps[chat_id] = house_map\n        logger.info(f\"‚úì Loaded {len(house_map)} houses from {houses_file} for group {chat_id}\")\n        return house_map\n    except FileNotFoundError:\n        logger.warning(f\"‚ö†Ô∏è Houses file {houses_file} not found for group {chat_id}\")\n        house_maps[chat_id] = {}\n        return {}\n    except Exception as e:\n        logger.error(f\"‚ùå Error loading houses for group {chat_id}: {e}\")\n        house_maps[chat_id] = {}\n        return {}\n\n# Load processed message IDs (composite keys: chat_id, message_id, thread_id)\ntry:\n    with open(PROCESSED_MESSAGES_FILE, 'r', encoding='utf-8') as f:\n        loaded_data = json.load(f)\n        # Convert list of lists back to set of tuples\n        processed_message_ids = set(tuple(item) for item in loaded_data)\n    logger.info(f\"‚úì Loaded {len(processed_message_ids)} processed message IDs\")\nexcept:\n    logger.info(f\"‚úì Starting fresh - no processed messages file found\")\n    processed_message_ids = set()\n\ndef save_processed_messages():\n    \"\"\"Save processed message IDs to file (as list of lists for JSON compatibility)\"\"\"\n    try:\n        with open(PROCESSED_MESSAGES_FILE, 'w', encoding='utf-8') as f:\n            # Convert set of tuples to list of lists for JSON serialization\n            json.dump([list(item) for item in processed_message_ids], f)\n    except Exception as e:\n        logger.error(f\"Error saving processed messages: {e}\")\n\n\n# ========== GOOGLE SHEETS ==========\n# Ethiopian months in order for tracking (must match ETHIOPIAN_MONTHS_LIST)\nETHIOPIAN_MONTHS = ETHIOPIAN_MONTHS_LIST\n\n# Cache for per-group Google Sheets: {chat_id: {reason: sheet}}\nsheets_cache = {}\n\ndef setup_sheets(chat_id: int):\n    \"\"\"Setup Google Sheets with monthly tracking format for a specific group\"\"\"\n    # Return cached sheets if available\n    if chat_id in sheets_cache:\n        return sheets_cache[chat_id]\n    \n    if chat_id not in GROUP_CONFIGS:\n        logger.error(f\"‚ùå Unknown chat_id {chat_id}, cannot setup sheets\")\n        return {}\n    \n    try:\n        scope = [\n            'https://spreadsheets.google.com/feeds',\n            'https://www.googleapis.com/auth/drive'\n        ]\n        creds = ServiceAccountCredentials.from_json_keyfile_name(\n            CREDENTIALS_FILE, scope)\n        gc = gspread.authorize(creds)\n        \n        # Get spreadsheet ID for this specific group\n        group_config = GROUP_CONFIGS[chat_id]\n        spreadsheet_id = group_config['spreadsheet_id']\n        spreadsheet = gc.open_by_key(spreadsheet_id)\n        logger.info(f\"‚úì Opened spreadsheet {spreadsheet_id} for group {chat_id}\")\n\n        sheets = {}\n        \n        # Load houses for this specific group\n        house_map = load_houses_for_group(chat_id)\n        \n        # Get sorted house numbers for consistent ordering\n        sorted_houses = sorted(house_map.keys(), key=lambda x: int(x))\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = spreadsheet.worksheet(reason.capitalize())\n                logger.info(f\"Sheet '{reason}' exists, checking structure...\")\n                \n                # Remove any table view/filters\n                try:\n                    sheet.clear_basic_filter()\n                    logger.info(f\"‚úì Cleared table view/filters from '{reason}'\")\n                except Exception as e:\n                    logger.info(f\"No table view to clear from '{reason}' (or error: {e})\")\n                \n                # Check if it needs restructuring (old format vs new 2-column format)\n                all_values = sheet.get_all_values()\n                # Check if headers match current 2-column format (2 header rows)\n                if len(all_values) > 1 and all_values[0][0] == 'No':\n                    # Row 1: Month names spanning 2 columns\n                    # Row 2: Amount, FT No sub-headers\n                    # Check column 3 (index 3) = first month name, column 4 (index 4) = empty (span)\n                    # Check row 2 has \"Amount\" and \"FT No\" sub-headers\n                    # Check for TOTAL row at the bottom (should have \"TOTAL\" in column B)\n                    has_correct_headers = (len(all_values[0]) > 4 and all_values[0][3] == ETHIOPIAN_MONTHS[0] and \n                        all_values[0][4] == '' and len(all_values[1]) > 4 and \n                        all_values[1][3] == 'Amount' and all_values[1][4] == 'FT No')\n                    \n                    has_totals_row = len(all_values) > 3 and any(row[1] == 'TOTAL' for row in all_values[2:])\n                    \n                    if has_correct_headers and has_totals_row:\n                        logger.info(f\"‚úì Sheet '{reason}' already has 2-column monthly format with TOTALS row\")\n                        sheets[reason] = sheet\n                        continue\n                    elif has_correct_headers and not has_totals_row:\n                        logger.info(f\"Sheet '{reason}' has format but missing TOTALS row, adding it...\")\n                        # Add totals row to existing sheet\n                        num_houses = len(all_values) - 2  # Subtract 2 header rows\n                        totals_row_num = len(all_values) + 1\n                        totals_row_data = ['', 'TOTAL', '']\n                        \n                        def num_to_col(n):\n                            string = \"\"\n                            while n > 0:\n                                n, remainder = divmod(n - 1, 26)\n                                string = chr(65 + remainder) + string\n                            return string\n                        \n                        for month_idx in range(len(ETHIOPIAN_MONTHS)):\n                            amount_col_idx = 3 + (month_idx * 2)\n                            amount_col_letter = num_to_col(amount_col_idx + 1)\n                            sum_formula = f'=SUM({amount_col_letter}3:{amount_col_letter}{totals_row_num - 1})'\n                            totals_row_data.append(sum_formula)\n                            totals_row_data.append('')\n                        totals_row_data.append('')\n                        \n                        sheet.update(f'A{totals_row_num}', [totals_row_data], value_input_option='USER_ENTERED')\n                        logger.info(f\"‚úì Added TOTALS row at row {totals_row_num}\")\n                        sheets[reason] = sheet\n                        continue\n                    else:\n                        logger.info(f\"Sheet '{reason}' has old format, rebuilding to 2-column...\")\n                        sheet.clear()\n                    \n                # Old format detected - clear and rebuild\n                logger.info(f\"Restructuring '{reason}' to 2-column monthly format...\")\n                sheet.clear()\n                \n            except:\n                # Sheet doesn't exist - create new one\n                logger.info(f\"Creating new sheet '{reason}' with monthly tracking...\")\n                sheet = spreadsheet.add_worksheet(title=reason.capitalize(),\n                                                  rows=100,\n                                                  cols=50)\n            \n            # Build 2-row header structure\n            # Row 1: Month names (each spanning 2 columns)\n            header_row1 = ['No', 'H.No', 'Name']\n            for month in ETHIOPIAN_MONTHS:\n                header_row1.extend([month, ''])  # Month name spans 2 columns\n            header_row1.append('Remark')\n            \n            # Row 2: Amount and FT No sub-headers under each month\n            header_row2 = ['', '', '']  # Empty under No, H.No, Name\n            for _ in ETHIOPIAN_MONTHS:\n                header_row2.extend(['Amount', 'FT No'])\n            header_row2.append('')  # Empty under Remark\n            \n            # Write both header rows (spans full width)\n            sheet.update('A1', [header_row1, header_row2], value_input_option='USER_ENTERED')\n            \n            # Pre-populate all houses (batch update for efficiency)\n            all_house_rows = []\n            for idx, house_num in enumerate(sorted_houses, start=1):\n                house_name = house_map[house_num]\n                # Create row with house info + empty cells for all months\n                row_data = [idx, house_num, house_name]\n                # Add empty cells for each month (2 columns per month: Amount, FT No)\n                row_data.extend([''] * (len(ETHIOPIAN_MONTHS) * 2))\n                row_data.append('')  # Remark column\n                all_house_rows.append(row_data)\n            \n            # Batch update all houses at once\n            if all_house_rows:\n                end_row = 2 + len(all_house_rows)  # Row 1-2 are headers, data starts at row 3\n                # Calculate the last column letter (No + H.No + Name + 13 months * 2 cols + Remark)\n                num_cols = 3 + (len(ETHIOPIAN_MONTHS) * 2) + 1\n                # Convert to letter\n                def num_to_col(n):\n                    string = \"\"\n                    while n > 0:\n                        n, remainder = divmod(n - 1, 26)\n                        string = chr(65 + remainder) + string\n                    return string\n                end_col = num_to_col(num_cols)\n                sheet.update(f'A3:{end_col}{end_row}', all_house_rows, value_input_option='USER_ENTERED')\n                \n                # Add TOTALS row after all houses with SUM formulas for each month\n                totals_row_num = end_row + 1\n                totals_row_data = ['', 'TOTAL', '']  # Empty No, \"TOTAL\" label in H.No, empty Name\n                \n                # Add SUM formula for each month's Amount column\n                data_start_row = 3  # First house data row\n                data_end_row = end_row  # Last house data row\n                \n                for month_idx in range(len(ETHIOPIAN_MONTHS)):\n                    # Amount column for this month\n                    amount_col_idx = 3 + (month_idx * 2)\n                    amount_col_letter = num_to_col(amount_col_idx + 1)  # +1 because num_to_col is 1-indexed\n                    \n                    # SUM formula for this month's Amount column\n                    sum_formula = f'=SUM({amount_col_letter}{data_start_row}:{amount_col_letter}{data_end_row})'\n                    totals_row_data.append(sum_formula)\n                    \n                    # Empty for FT No column\n                    totals_row_data.append('')\n                \n                # Empty for Remark column\n                totals_row_data.append('')\n                \n                # Write the totals row\n                sheet.update(f'A{totals_row_num}', [totals_row_data], value_input_option='USER_ENTERED')\n                logger.info(f\"‚úì Added TOTALS row at row {totals_row_num}\")\n            \n            logger.info(f\"‚úì Created '{reason}' with {len(sorted_houses)} houses and {len(ETHIOPIAN_MONTHS)} month columns\")\n            sheets[reason] = sheet\n\n        logger.info(f\"‚úì Google Sheets ready ({len(sheets)} sheets)\")\n        sheets_cache[chat_id] = sheets\n        return sheets\n    except Exception as e:\n        logger.error(f\"‚úó Sheets error: {e}\")\n        return None\n\n\n# ========== OCR ==========\ndef extract_text_from_image(image_bytes):\n    \"\"\"Extract text from image using OCR with retry logic\"\"\"\n    max_retries = 3\n    timeout_seconds = 45\n    \n    for attempt in range(1, max_retries + 1):\n        try:\n            if attempt > 1:\n                logger.info(f\"üì∏ Retrying OCR (attempt {attempt}/{max_retries})...\")\n            else:\n                logger.info(\"üì∏ Running OCR...\")\n\n            payload = {\n                'apikey': OCR_API_KEY,\n                'language': 'eng',\n                'isOverlayRequired': False,\n                'detectOrientation': True,\n                'scale': True,\n                'OCREngine': 2\n            }\n\n            files = {'file': ('image.jpg', image_bytes, 'image/jpeg')}\n            response = requests.post(OCR_API_URL,\n                                     files=files,\n                                     data=payload,\n                                     timeout=timeout_seconds)\n\n            if response.status_code == 200:\n                result = response.json()\n                if not result.get('IsErroredOnProcessing'):\n                    text = result.get('ParsedResults',\n                                      [{}])[0].get('ParsedText', '')\n                    logger.info(f\"‚úì OCR done: {len(text)} chars\")\n                    return text\n                else:\n                    logger.warning(f\"‚úó OCR processing error on attempt {attempt}\")\n            else:\n                logger.warning(f\"‚úó OCR failed with status {response.status_code} on attempt {attempt}\")\n\n        except requests.exceptions.Timeout:\n            logger.warning(f\"‚úó OCR timeout on attempt {attempt}/{max_retries}\")\n            if attempt == max_retries:\n                logger.error(\"‚úó OCR failed after all retries (timeout)\")\n                return \"\"\n            continue\n        except Exception as e:\n            logger.error(f\"‚úó OCR error on attempt {attempt}: {e}\")\n            if attempt == max_retries:\n                return \"\"\n            continue\n    \n    logger.warning(f\"‚úó OCR failed after {max_retries} attempts\")\n    return \"\"\n\n\n# ========== RECEIPT-SPECIFIC EXTRACTION ==========\n\n\ndef normalize_amount_lines(text):\n    \"\"\"Preprocess OCR text to join amount labels with their values on separate lines.\n    \n    Handles table-based layouts (e.g., Zemen Bank) where labels like \"Settled Amount\"\n    appear on one line and the value \"ETB 1,000.00\" appears on the next line.\n    \"\"\"\n    lines = text.split('\\n')\n    normalized_lines = []\n    \n    amount_labels = ['settled amount', 'settled', 'amount paid', 'paid', 'debited', 'credited', \n                     'subtotal', 'sub-total', 'sub total', 'total amount']\n    \n    i = 0\n    while i < len(lines):\n        line = lines[i].strip()\n        \n        if not line:\n            i += 1\n            continue\n        \n        line_lower = line.lower()\n        has_amount_label = any(label in line_lower for label in amount_labels)\n        \n        # Check if next line starts with ETB or has currency pattern\n        should_combine = False\n        if has_amount_label and i + 1 < len(lines):\n            next_line = lines[i + 1].strip()\n            # Check if next line starts with ETB, birr, or has amount pattern\n            if next_line and (next_line.upper().startswith('ETB') or \n                             re.match(r'^[0-9,]+\\.[0-9]{2}', next_line)):\n                should_combine = True\n        \n        if should_combine:\n            combined = line + ' ' + lines[i + 1].strip()\n            normalized_lines.append(combined)\n            i += 2\n        else:\n            normalized_lines.append(line)\n            i += 1\n    \n    return '\\n'.join(normalized_lines)\n\n\ndef extract_amount_from_receipt(text):\n    \"\"\"Extract amount from receipt (WITHOUT VAT if possible)\"\"\"\n    logger.info(\"Extracting AMOUNT (without VAT)...\")\n    \n    normalized_text = normalize_amount_lines(text)\n    logger.info(f\"üìù Normalized text preview: {normalized_text[:500]}...\")\n\n    # Try normalized text first, then fall back to original text\n    for search_text in [normalized_text, text]:\n        # Priority 1: Look for \"Settled Amount\" specifically (Zemen Bank format)\n        settled_pattern = r'settled\\s+amount[:\\s]*ETB\\s*([0-9,]+(?:\\.[0-9]{2})?)'\n        match = re.search(settled_pattern, search_text, re.IGNORECASE | re.DOTALL)\n        if match:\n            amount_str = match.group(1).replace(',', '')\n            try:\n                amount_val = float(amount_str)\n                if amount_val > 50:\n                    logger.info(f\"‚úì Amount (Settled Amount): {amount_str}\")\n                    return amount_str\n            except:\n                pass\n        \n        # Priority 2: Look for amounts specifically marked as WITHOUT VAT or Subtotal\n        without_vat_patterns = [\n            r'(?:subtotal|sub-total|sub total|before vat|excluding vat|excl\\.? vat)[:\\s]*(?:ETB|birr|·â•·à≠)?\\s*([0-9,]+(?:\\.[0-9]{2})?)',\n            r'(?:ETB|birr|·â•·à≠)?\\s*([0-9,]+(?:\\.[0-9]{2})?)\\s*(?:before vat|excluding vat|excl\\.? vat)',\n        ]\n\n        for pattern in without_vat_patterns:\n            match = re.search(pattern, search_text, re.IGNORECASE)\n            if match:\n                amount_str = match.group(1).replace(',', '')\n                try:\n                    amount_val = float(amount_str)\n                    if amount_val > 50:\n                        logger.info(f\"‚úì Amount (without VAT): {amount_str}\")\n                        return amount_str\n                except:\n                    pass\n\n        # Priority 3: Look for \"ETB X debited\" pattern (base amount, not total)\n        debited_pattern = r'ETB\\s*([0-9,]+(?:\\.[0-9]{2})?)\\s+debited'\n        match = re.search(debited_pattern, search_text, re.IGNORECASE)\n        if match:\n            amount_str = match.group(1).replace(',', '')\n            try:\n                amount_val = float(amount_str)\n                if amount_val > 50:\n                    match_pos = match.start()\n                    preceding_text = search_text[max(0, match_pos - 50):match_pos]\n                    if 'total' not in preceding_text.lower():\n                        logger.info(f\"‚úì Amount (debited, no VAT): {amount_str}\")\n                        return amount_str\n            except:\n                pass\n\n        # Priority 4: Standard amount extraction (fallback)\n        standard_patterns = [\n            r'(?:debited|Debited|DEBITED).*?ETB\\s*([0-9,]+(?:\\.[0-9]{2})?)',\n            r'(?:Amount|amount|AMOUNT).*?(?:ETB|birr)?\\s*([0-9,]+(?:\\.[0-9]{2})?)',\n            r'(?:ETB|birr|·â•·à≠)\\s*([0-9,]+(?:\\.[0-9]{2})?)',\n            r'([0-9,]+(?:\\.[0-9]{2})?)\\s*(?:ETB|birr|·â•·à≠)',\n        ]\n\n        all_amounts = []\n        for pattern in standard_patterns:\n            for match in re.finditer(pattern, search_text, re.IGNORECASE):\n                amount_str = match.group(1).replace(',', '')\n                try:\n                    amount_val = float(amount_str)\n                    if amount_val > 50:\n                        match_pos = match.start()\n                        context = search_text[max(0, match_pos - 30):min(len(search_text), match_pos + 100)]\n                        # Exclude total amounts and service charges\n                        if 'total' not in context.lower() and 'with commission' not in context.lower() and 'service charge' not in context.lower() and 'vat' not in context.lower():\n                            all_amounts.append(amount_val)\n                            logger.info(f\"  Found candidate: {amount_val} (context: ...{context[:50]}...)\")\n                except:\n                    pass\n\n        # Return the smallest valid amount (likely without VAT)\n        if all_amounts:\n            min_amount = min(all_amounts)\n            logger.info(f\"‚úì Amount (smallest, likely without VAT): {min_amount}\")\n            return str(min_amount)\n\n    logger.warning(\"‚úó Amount not found\")\n    return \"\"\n\n\ndef extract_date_from_receipt(text):\n    \"\"\"Extract date from receipt\"\"\"\n    logger.info(\"Extracting DATE...\")\n\n    patterns = [\n        r'(\\d{1,2}[-/]\\w{3}[-/]\\d{4})',\n        r'(\\d{1,2}\\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\\s+\\d{4})',\n        r'on\\s+(\\d{1,2}[-/]\\w{3}[-/]\\d{4})',\n    ]\n\n    for pattern in patterns:\n        match = re.search(pattern, text, re.IGNORECASE)\n        if match:\n            date = match.group(1)\n            logger.info(f\"‚úì Date: {date}\")\n            return date\n\n    logger.warning(\"‚úó Date not found\")\n    return \"\"\n\n\ndef extract_txid_from_receipt(text):\n    \"\"\"Extract transaction ID from receipt\"\"\"\n    logger.info(\"Extracting TRANSACTION ID...\")\n    logger.info(f\"üîç Full OCR text for TxID extraction ({len(text)} chars):\\n{text[:1500]}\")\n\n    # Words to exclude from transaction ID matches (common labels on receipts)\n    excluded_words = [\n        'transaction', 'reference', 'number', 'invoice', 'receipt', 'details',\n        'reason', 'type', 'time', 'date', 'amount', 'account', 'completed',\n        'payment', 'transfer', 'charge', 'commission', 'sender', 'nolawi'\n    ]\n\n    # Priority 1: Payment order number or Reference No (Zemen Bank specific)\n    # Look for patterns near these labels, even if the value is on a different line\n    zemen_patterns = [\n        r'(?:payment\\s+order\\s+number|reference\\s+no\\.?)[:\\s]*\\n?\\s*([A-Z0-9]{10,})',\n        r'(?:payment\\s+order\\s+number|reference\\s+no\\.?)[:\\s]+([A-Z0-9]{10,})',\n        r'(?:thy\\s+HY\\s+PiP\\s+Payment\\s+order\\s+number)[:\\s]*\\n?\\s*([A-Z0-9]{10,})',  # OCR-specific pattern\n    ]\n    \n    for pattern in zemen_patterns:\n        match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)\n        if match:\n            txid = match.group(1).strip()\n            logger.info(f\"üîç Found candidate from Zemen pattern: {txid}\")\n            # Must be alphanumeric, at least 10 chars, and not just the word \"payment reason\"\n            if (len(txid) >= 10 and txid.lower() not in excluded_words\n                    and any(c.isdigit() for c in txid) and any(c.isalpha() for c in txid)\n                    and 'reason' not in txid.lower()):\n                logger.info(f\"‚úì TxID (Payment Order/Reference): {txid}\")\n                return txid\n\n    # Priority 2: Transaction ID variants\n    priority_patterns = [\n        # Transaction ID variants WITH COLON\n        r'(?:transaction\\s+id|tx\\s+id|txid|tran\\s+ref)\\s*:\\s*([A-Za-z0-9]+)',\n\n        # Transaction ID variants WITHOUT COLON (just whitespace)\n        r'(?:transaction\\s+id|tx\\s+id|txid|tran\\s+ref)\\s+([A-Za-z0-9]+)',\n\n        # VAT invoice/receipt patterns with optional parentheses\n        r'(?:reference\\s+no\\.?\\s*\\(vat\\s+invoice\\s+no\\.?\\)|vat\\s+invoice\\s+no\\.?)\\s*:\\s*([A-Za-z0-9]+)',\n        r'(?:vat\\s+receipt\\s+number|vat\\s+receipt\\s+no\\.?)\\s*:\\s*([A-Za-z0-9]+)',\n        r'(?:vat\\s+invoice\\s+number|vat\\s+invoice\\s+no\\.?)\\s*:\\s*([A-Za-z0-9]+)',\n\n        # Generic reference patterns (but NOT payment reason)\n        r'(?:reference\\s+number|ref\\s+no\\.?)\\s*:\\s*([A-Za-z0-9]+)',\n    ]\n\n    for pattern in priority_patterns:\n        match = re.search(pattern, text, re.IGNORECASE)\n        if match:\n            txid = match.group(1).strip()\n            # Filter out common words and require mixed alphanumeric\n            if (len(txid) >= 5 and txid.lower() not in excluded_words\n                    and not txid.isnumeric() and not txid.isalpha()\n                    and any(c.isdigit() for c in txid) and any(c.isalpha() for c in txid)\n                    and 'reason' not in txid.lower()):\n                logger.info(f\"‚úì TxID: {txid}\")\n                return txid\n\n    # Fallback: hyphenated format (e.g., ABC-DEF-123) but NOT dates or currency patterns\n    matches = re.findall(r'([A-Za-z0-9]+-[A-Za-z0-9]+-[A-Za-z0-9]+)', text)\n    for match in matches:\n        # Must contain at least one letter (exclude pure date formats like 2025-11-05)\n        # Also exclude currency-related patterns (ETB, BIRR, FTB) and payment reason patterns\n        match_upper = match.upper()\n        if (any(c.isalpha() for c in match) and len(match) >= 8\n                and match.lower() not in excluded_words\n                and not any(currency in match_upper for currency in ['ETB', 'BIRR', 'FTB'])\n                and 'reason' not in match.lower()):\n            logger.info(f\"‚úì TxID (hyphenated): {match}\")\n            return match\n\n    # Fallback: any alphanumeric 10+ characters but SKIP patterns near \"payment reason\"\n    # First, check if this appears near \"payment reason\" and skip it\n    lines = text.split('\\n')\n    for i, line in enumerate(lines):\n        if 'payment reason' in line.lower():\n            # Find alphanumeric patterns in this line\n            reason_matches = re.findall(r'([A-Z0-9]{8,})', line, re.IGNORECASE)\n            # Mark these for exclusion\n            excluded_words.extend([m.lower() for m in reason_matches])\n    \n    matches = re.findall(\n        r'\\b([A-Z]{2}[A-Za-z0-9]{8,}|[0-9]{2}[A-Z]{2,}[A-Z0-9]{6,}|[A-Z0-9]{10,})\\b', text)\n    for match in matches:\n        # Must contain at least one letter and one number, and not be a common word or payment reason\n        if (match.lower() not in excluded_words and not match.isnumeric()\n                and not match.isalpha() and any(c.isdigit() for c in match)\n                and any(c.isalpha() for c in match)):\n            logger.info(f\"‚úì TxID (alphanumeric): {match}\")\n            return match\n\n    logger.warning(\"‚úó TxID not found\")\n    return \"\"\n\n\ndef extract_name_from_receipt(text):\n    \"\"\"Extract name from receipt (payer, not beneficiary)\"\"\"\n    logger.info(\"Extracting NAME...\")\n\n    patterns = [\n        r'(?:debited from|from|paid by|payer)[:\\s]+([A-Z][A-Za-z\\s]+?)(?:\\n|for|with)',\n        r'(?:ABATE|payer|account holder)[:\\s]+([A-Z][A-Za-z\\s]+?)(?:\\n|for|on)',\n        r'([A-Z][A-Z][A-Z\\s]{2,}?)(?:\\n|for|BUNAGO)',\n    ]\n\n    for pattern in patterns:\n        match = re.search(pattern, text, re.IGNORECASE)\n        if match:\n            name = match.group(1).strip()\n            name = re.sub(r'\\s+', ' ', name).strip()\n            if len(name) > 3 and len(name) < 50:\n                logger.info(f\"‚úì Name: {name}\")\n                return name\n\n    logger.warning(\"‚úó Name not found\")\n    return \"\"\n\n\ndef extract_beneficiary_from_receipt(text):\n    \"\"\"Extract beneficiary/receiver from receipt (who received the payment)\n    \n    Handles table-based layouts where labels and values are separated.\n    \"\"\"\n    logger.info(\"Extracting BENEFICIARY...\")\n    logger.info(f\"Full OCR text ({len(text)} chars):\\n{text}\")  # DEBUG: See full text\n\n    # Normalize Unicode dashes to ASCII hyphens (OCR often emits en-dash/em-dash)\n    text = text.replace('\\u2013', '-').replace('\\u2014', '-')  # en-dash, em-dash ‚Üí hyphen\n    \n    # STRATEGY 1: Look for \"Receiver Name\" label SPECIFICALLY, then find the corresponding VALUE\n    # In table layouts, the value appears AFTER all labels, in the same position\n    # CRITICAL: Must match \"Receiver Name\" NOT \"Receiver Account\"\n    receiver_label_match = re.search(r'(?<!Source\\s)(?<!Source Account\\s)\\b(Receiver Name|Beneficiary Name|Beneficiary)\\b', text, re.IGNORECASE)\n    \n    if receiver_label_match:\n        logger.info(f\"Found receiver label at position {receiver_label_match.start()}: '{receiver_label_match.group(1)}'\")\n        \n        # Split text into lines\n        lines = text.split('\\n')\n        receiver_label_line_idx = None\n        \n        # Find which line contains the receiver NAME label (NOT receiver account)\n        for i, line in enumerate(lines):\n            # MUST match \"Receiver Name\" or \"Beneficiary Name\", NOT just \"Receiver\" or \"Receiver Account\"\n            if re.search(r'\\b(Receiver Name|Beneficiary Name|Beneficiary)\\b', line, re.IGNORECASE):\n                # Make sure it's not \"Source Account Name\"\n                if not re.search(r'Source', line, re.IGNORECASE):\n                    receiver_label_line_idx = i\n                    logger.info(f\"Receiver NAME label found on line {i}: '{line}'\")\n                    break\n        \n        if receiver_label_line_idx is not None:\n            # Strategy: Look for the value in nearby lines (within 5-10 lines after the label)\n            # The value should be a sequence of uppercase words, possibly with \"AND OR\"\n            search_start = receiver_label_line_idx + 1\n            search_end = min(receiver_label_line_idx + 12, len(lines))\n            \n            logger.info(f\"Searching for receiver value in lines {search_start} to {search_end}\")\n            \n            # Track candidates to find the right one\n            candidates = []\n            \n            for i in range(search_start, search_end):\n                line = lines[i].strip()\n                logger.info(f\"Checking line {i}: '{line}'\")\n                \n                # Skip empty lines\n                if not line:\n                    continue\n                \n                # Skip lines that are clearly labels or numbers\n                if re.match(r'^\\d', line):  # Starts with digit\n                    logger.info(f\"  Skipping (starts with digit)\")\n                    continue\n                if re.search(r'(Transaction|Reference|Type|Bank|Note|Account|Amount|Date|Time|Source|ETB|FTB)', line, re.IGNORECASE):\n                    logger.info(f\"  Skipping (contains field keyword)\")\n                    continue\n                \n                # Look for uppercase name pattern (possibly with AND OR)\n                if re.search(r'\\b[A-Z]{2,}\\s+[A-Z]{2,}', line):\n                    # Found a potential name - clean it up\n                    beneficiary = line.strip()\n                    beneficiary = re.sub(r'AND\\s*/\\s*OR', 'AND OR', beneficiary, flags=re.IGNORECASE)\n                    beneficiary = re.sub(r'ANDOR', 'AND OR', beneficiary, flags=re.IGNORECASE)\n                    beneficiary = re.sub(r'\\s+', ' ', beneficiary).strip()\n                    \n                    # Remove common suffixes\n                    beneficiary = re.sub(r'\\s+(ETB|FTB|BIRR).*$', '', beneficiary, flags=re.IGNORECASE)\n                    \n                    # Validate: at least 2 words or contains \"AND OR\"\n                    if len(beneficiary.split()) >= 2 or 'AND OR' in beneficiary.upper():\n                        # Exclude known source account names\n                        if beneficiary.upper() in ['SEBLE FULIE SHUME', 'SEBLE FULIE', 'FULIE SHUME']:\n                            logger.info(f\"  Skipping source account name: '{beneficiary}'\")\n                            continue\n                        candidates.append(beneficiary)\n                        logger.info(f\"  Found candidate: '{beneficiary}'\")\n            \n            # Prefer candidates containing \"AND OR\" (joint accounts)\n            for cand in candidates:\n                if 'AND OR' in cand.upper():\n                    logger.info(f\"‚úì Beneficiary (table layout - joint account): {cand}\")\n                    return cand\n            \n            # Otherwise return the first valid candidate\n            if candidates:\n                logger.info(f\"‚úì Beneficiary (table layout - first candidate): {candidates[0]}\")\n                return candidates[0]\n    \n    logger.info(\"Table layout strategy didn't work, trying direct pattern matching...\")\n\n\n    # FALLBACK: Generic name extraction (similar to TXID approach)\n    # Look for any sequence of uppercase words that could be a name\n    logger.info(\"Priority patterns didn't match, trying fallback extraction...\")\n    \n    # Fallback 1: Look for \"WORD WORD AND OR WORD WORD\" pattern (joint account names)\n    # e.g., \"JOHN DOE AND OR JANE SMITH\" or \"SEYSOA ASSEFA AND OR SENAIT DAGNE\"\n    joint_patterns = [\n        r'([A-Z][A-Z]+\\s+[A-Z][A-Z]+\\s+AND\\s+OR\\s+[A-Z][A-Z]+\\s+[A-Z][A-Z]+)',\n        r'([A-Z][A-Z]+\\s+[A-Z][A-Z]+\\s+AND\\s*/\\s*OR\\s+[A-Z][A-Z]+\\s+[A-Z][A-Z]+)',\n        r'([A-Z][A-Z]+\\s+[A-Z][A-Z]+\\s+ANDOR\\s+[A-Z][A-Z]+\\s+[A-Z][A-Z]+)',\n    ]\n    \n    for pattern in joint_patterns:\n        match = re.search(pattern, text, re.IGNORECASE)\n        if match:\n            beneficiary = match.group(1).strip()\n            beneficiary = re.sub(r'\\s+', ' ', beneficiary).strip()\n            if 10 <= len(beneficiary) <= 80:  # Reasonable length for joint names\n                logger.info(f\"‚úì Beneficiary (fallback - joint account): {beneficiary}\")\n                return beneficiary\n    \n    # Fallback 2: Look for any sequence of 2-4 uppercase words (individual names)\n    # Must be at least 2 words, each word at least 2 chars\n    # e.g., \"JOHN DOE\", \"MARY JANE SMITH\"\n    # CRITICAL: Must appear AFTER \"Receiver\" context, NOT after \"Source\"\n    \n    # Strategy: Split text by lines and look for names that appear in receiver context\n    lines = text.split('\\n')\n    for i, line in enumerate(lines):\n        # Check if this line or previous line mentions \"Receiver\" or \"Beneficiary\"\n        context = '\\n'.join(lines[max(0, i-2):i+1])  # Look at previous 2 lines + current\n        \n        # Skip if in \"Source\" context\n        if re.search(r'source\\s+account\\s+name', context, re.IGNORECASE):\n            continue\n            \n        # Look for receiver context\n        if re.search(r'receiver|beneficiary|payee|paid to|credited to', context, re.IGNORECASE):\n            # Extract name from current line\n            name_pattern = r'\\b([A-Z]{2,}\\s+[A-Z]{2,}(?:\\s+[A-Z]{2,}){0,4})\\b'\n            match = re.search(name_pattern, line)\n            if match:\n                name = match.group(1)\n                # Skip if it's a label/field name\n                excluded_words = ['ACCOUNT NAME', 'RECEIVER NAME', 'SOURCE ACCOUNT', 'TRANSACTION', 'REFERENCE', 'BANK NAME']\n                if any(excl in name for excl in excluded_words):\n                    continue\n                if 5 <= len(name) <= 80 and len(name.split()) >= 2:\n                    logger.info(f\"‚úì Beneficiary (fallback - receiver context): {name}\")\n                    return name\n    \n    # Last resort: generic name matching with strict exclusions\n    name_pattern = r'\\b([A-Z]{2,}\\s+[A-Z]{2,}(?:\\s+[A-Z]{2,}){0,2})\\b'\n    matches = re.findall(name_pattern, text)\n    \n    # Filter out common non-name phrases\n    excluded_phrases = [\n        'BANK OF', 'COMMERCIAL BANK', 'TRANSACTION TYPE', 'ACCOUNT NUMBER',\n        'REFERENCE NUMBER', 'TRANSACTION DATE', 'TRANSACTION ID', 'SOURCE ACCOUNT',\n        'RECEIVER ACCOUNT', 'ACCOUNT NAME', 'RECEIVER NAME', 'BENEFICIARY NAME',\n        'OTHER BANK', 'BANK TRANSFER', 'THE CHOICE', 'SCAN THE', 'CHOICE FOR',\n        'SEBLE FULIE', 'FULIE SHUME'  # Exclude known source account names\n    ]\n    \n    for match in matches:\n        # Skip if it's a common phrase\n        if any(excl in match.upper() for excl in excluded_phrases):\n            continue\n        # Skip if it contains only common words\n        if all(word in ['THE', 'FOR', 'AND', 'OR', 'OF', 'TO', 'FROM'] for word in match.split()):\n            continue\n        # Must be reasonable length\n        if 5 <= len(match) <= 60 and len(match.split()) >= 2:\n            logger.info(f\"‚úì Beneficiary (fallback - name pattern): {match}\")\n            return match\n\n    logger.warning(\"‚úó Beneficiary not found in receipt text (all patterns exhausted)\")\n    logger.info(f\"Receipt text sample (first 400 chars): {text[:400]}\")\n    # Log full text for debugging (but limit to 1000 chars to avoid spam)\n    if len(text) > 200:\n        logger.debug(f\"Full receipt text ({len(text)} chars): {text[:1000]}\")\n    return \"\"\n\n\ndef normalize_name(name):\n    \"\"\"Normalize name for comparison: uppercase, remove punctuation, collapse whitespace\"\"\"\n    if not name:\n        return \"\"\n    # Uppercase\n    name = name.upper()\n    # Normalize \"and/or\" variations to \"AND OR\" before removing punctuation\n    name = re.sub(r'AND\\s*/\\s*OR', 'AND OR', name)\n    name = re.sub(r'&', 'AND', name)\n    # Remove punctuation except spaces\n    name = re.sub(r'[^\\w\\s]', ' ', name)\n    # Collapse whitespace\n    name = re.sub(r'\\s+', ' ', name).strip()\n    return name\n\n\ndef validate_beneficiary(beneficiary_text):\n    \"\"\"\n    Validate if beneficiary matches expected account names.\n    Accepts receipts where at least one authorized person's full name is present.\n    Returns (is_valid, normalized_beneficiary)\n    \"\"\"\n    if not beneficiary_text:\n        # If no beneficiary found, REJECT - cannot verify correct account\n        logger.warning(\"‚ùå No beneficiary extracted - cannot validate payment account\")\n        return False, \"\"\n    \n    # Normalize the extracted beneficiary\n    normalized = normalize_name(beneficiary_text)\n    logger.info(f\"üîç Validating beneficiary: '{normalized}'\")\n    \n    # Tokenize extracted beneficiary\n    extracted_tokens = set(normalized.split())\n    \n    # Expanded connector words to handle \"AND OR\", \"ANDOR\", etc.\n    connectors = {'AND', 'OR', 'ANDOR', 'THE', 'OF', 'TO', 'A', 'AN', '&', '/'}\n    extracted_tokens_clean = extracted_tokens - connectors\n    \n    logger.info(f\"Extracted tokens (cleaned): {extracted_tokens_clean}\")\n    \n    # Authorized tokens - accept if ANY of these is found\n    # FULL ACCOUNT NAME: \"SEYOUM ASSEFA AND OR SENAIT DAGNE\"\n    # BUT accept ANY PARTIAL match (receipt may show truncated name)\n    # Include ALL possible spelling variations due to OCR errors\n    authorized_tokens = {\n        # First name variations\n        'SEYOUM', 'SEYSOA', 'SEYSOM', 'SEYSUM', 'SEYOAM',\n        # First surname variations\n        'ASSEFA', 'ASEFA', 'ASEFFA',\n        # Second name variations\n        'SENAIT', 'SENIET', 'SENAYT', 'SENAITE',\n        # Second surname variations\n        'DAGNIE', 'DAGNE', 'DAGINE', 'DAGNY', 'DAGNHE'\n    }\n    \n    # Check if ANY authorized token is present (even just one word from the full name)\n    matching_tokens = extracted_tokens_clean & authorized_tokens\n    \n    if matching_tokens:\n        logger.info(f\"‚úÖ Beneficiary VALID - found authorized token(s): {matching_tokens}\")\n        logger.info(f\"   (Partial match accepted - receipt may show truncated name)\")\n        return True, normalized\n    \n    # No match found\n    logger.warning(f\"‚ùå Beneficiary INVALID: '{normalized}' does not contain any authorized tokens\")\n    logger.info(f\"Expected to find at least one of: {sorted(authorized_tokens)}\")\n    logger.info(f\"Note: Receipt should contain SEYOUM ASSEFA AND OR SENAIT DAGNE (or any portion)\")\n    return False, normalized\n\n\ndef extract_house_from_caption(caption):\n    \"\"\"Extract house number from caption (3 or 4 digits only)\n    Handles mixed text like: '·â• 22 ·âÅ407' ‚Üí extracts '407'\n    Also handles slashed formats like: '14/06' ‚Üí '1406'\n    \"\"\"\n    if not caption:\n        return \"\"\n\n    # Find all numbers in the caption (even if mixed with text)\n    all_numbers = re.findall(r'[0-9]+', caption)\n\n    # Filter for only 3-4 digit numbers\n    for num in all_numbers:\n        if len(num) == 3 or len(num) == 4:\n            logger.info(f\"‚úì House (caption): {num}\")\n            return num\n\n    # If no 3-4 digit number found, try combining numbers separated by slashes or spaces\n    # Look for patterns like \"14/06\" or \"14 06\"\n    slash_pattern = re.search(r'(\\d{1,2})\\s*/\\s*(\\d{1,2})', caption)\n    if slash_pattern:\n        combined = slash_pattern.group(1) + slash_pattern.group(2)\n        if len(combined) == 3 or len(combined) == 4:\n            logger.info(f\"‚úì House (combined from slash): {combined}\")\n            return combined\n    \n    # Try combining consecutive small numbers separated by space\n    space_pattern = re.search(r'(\\d{1,2})\\s+(\\d{1,2})', caption)\n    if space_pattern:\n        combined = space_pattern.group(1) + space_pattern.group(2)\n        if len(combined) == 3 or len(combined) == 4:\n            logger.info(f\"‚úì House (combined from space): {combined}\")\n            return combined\n\n    logger.warning(\"‚úó House number not found (must be 3 or 4 digits)\")\n    return \"\"\n\n\ndef convert_to_ethiopian_month(text):\n    \"\"\"\n    Convert Gregorian or Ethiopian month to Ethiopian calendar month (English name)\n    CONVERSION - not just translation!\n    \n    Examples:\n    - \"january\" ‚Üí \"Tir\" (Ethiopian equivalent)\n    - \"february\" ‚Üí \"Yekatit\" (Ethiopian equivalent)\n    - \"meskerem\" ‚Üí \"Meskerem\" (already Ethiopian)\n    - \"·å•·à≠\" ‚Üí \"Tir\" (Amharic to English)\n    \n    Returns: English Ethiopian month name (e.g., \"Tir\", \"Meskerem\")\n    \"\"\"\n    logger.info(\"Converting to Ethiopian calendar...\")\n\n    text_lower = text.lower()\n\n    # Check if it's already an Ethiopian month (English)\n    for eth_month in ETHIOPIAN_MONTHS_LIST:\n        if eth_month.lower() in text_lower or eth_month in text:\n            logger.info(f\"‚úì Already Ethiopian month: {eth_month}\")\n            return eth_month\n\n    # Check if it's an Amharic month name - convert to English\n    for amharic_name, english_name in AMHARIC_TO_ETHIOPIAN.items():\n        if amharic_name in text:\n            logger.info(f\"‚úì Converted Amharic to English: {amharic_name} ‚Üí {english_name}\")\n            return english_name\n\n    # Convert Gregorian to Ethiopian (English name)\n    for gregorian, ethiopian in GREGORIAN_TO_ETHIOPIAN.items():\n        if gregorian in text_lower:\n            logger.info(\n                f\"‚úì Converted Gregorian to Ethiopian: {gregorian} ‚Üí {ethiopian}\"\n            )\n            return ethiopian\n\n    logger.warning(\"‚úó Month not found\")\n    return \"\"\n\n\n# ========== MAIN EXTRACTION ==========\ndef extract_payment_data(text, caption=\"\"):\n    \"\"\"Receipt-specific extraction (single message)\"\"\"\n    combined = caption + \"\\n\" + text if caption else text\n\n    logger.info(f\"=== EXTRACTION START ===\")\n    logger.info(f\"Caption: {caption[:100] if caption else 'N/A'}\")\n    logger.info(f\"Text: {text[:100] if text else 'N/A'}\")\n\n    # Extract fields\n    # Try caption first, then fall back to searching all combined text\n    house_number = extract_house_from_caption(caption)\n    if not house_number:\n        logger.info(\"House not in caption, searching combined text...\")\n        house_number = extract_house_from_caption(combined)\n\n    amount = extract_amount_from_receipt(combined)\n    date_str = extract_date_from_receipt(combined)\n    txid = extract_txid_from_receipt(combined)\n    name = extract_name_from_receipt(combined)\n\n    # House mapping\n    if house_number in house_map:\n        name = house_map[house_number]\n        logger.info(f\"‚úì Name (mapped): {name}\")\n\n    # Reason\n    reason = 'other'\n    text_lower = combined.lower()\n    for r, keywords in PAYMENT_REASONS.items():\n        for kw in keywords:\n            if kw.lower() in text_lower or kw in combined:\n                reason = r\n                break\n        if reason != 'other':\n            break\n\n    # Month - CONVERT to Ethiopian (not just translate!)\n    month = convert_to_ethiopian_month(combined)\n\n    logger.info(f\"=== EXTRACTION COMPLETE ===\")\n    logger.info(\n        f\"House={house_number}, Amount={amount}, Name={name}, Month={month} (Ethiopian)\"\n    )\n\n    return {\n        'house_number': house_number,\n        'amount': amount,\n        'payment_date': date_str,\n        'transaction_id': txid,\n        'name': name,\n        'reason': reason,\n        'month': month\n    }\n\n\ndef extract_payment_data_buffered(combined_text,\n                                  caption=\"\",\n                                  user_text=\"\",\n                                  is_edit_mode=False,\n                                  original_data=None,\n                                  chat_id=None):\n    \"\"\"Receipt-specific extraction for buffered messages\n    Prioritizes user-typed text for house number and month extraction\n    In edit mode, handles disambiguation for bare numbers (treats as amount by default)\n    \"\"\"\n    combined = caption + \"\\n\" + combined_text if caption else combined_text\n    \n    # Load house mapping for this chat\n    house_map = {}\n    if chat_id:\n        house_map = load_houses_for_group(chat_id)\n\n    logger.info(\n        f\"=== BUFFERED EXTRACTION START (edit_mode={is_edit_mode}) ===\")\n    logger.info(f\"Caption: {caption[:100] if caption else 'N/A'}\")\n    logger.info(f\"User text: {user_text[:100] if user_text else 'N/A'}\")\n    logger.info(f\"Combined: {combined_text[:100] if combined_text else 'N/A'}\")\n\n    # ========== EDIT MODE DISAMBIGUATION ==========\n    # Check for explicit field prefixes in user text\n    explicit_amount = None\n    explicit_house = None\n    explicit_month = None\n\n    if is_edit_mode and user_text:\n        # Check for explicit field labels (case insensitive)\n        user_lower = user_text.lower().strip()\n\n        # Amount: \"amount: 700\", \"amount 700\", \"700 birr\"\n        amount_match = re.search(r'(?:amount|birr|·â•·à≠)[:\\s]+([0-9.]+)',\n                                 user_lower)\n        if amount_match:\n            explicit_amount = amount_match.group(1)\n            logger.info(f\"‚úì Explicit amount label found: {explicit_amount}\")\n        elif re.search(r'([0-9.]+)\\s*(?:birr|·â•·à≠)', user_lower):\n            explicit_amount = re.search(r'([0-9.]+)\\s*(?:birr|·â•·à≠)',\n                                        user_lower).group(1)\n            logger.info(f\"‚úì Amount with currency found: {explicit_amount}\")\n\n        # House: \"house: 901\", \"house 901\", \"·â§·âµ 901\"\n        house_match = re.search(r'(?:house|·â§·âµ|home)[:\\s]+([0-9]{3,4})',\n                                user_lower)\n        if house_match:\n            explicit_house = house_match.group(1)\n            logger.info(f\"‚úì Explicit house label found: {explicit_house}\")\n\n        # Month: \"month: meskerem\", \"·ãà·à≠: ·àò·àµ·ä®·à®·àù\"\n        month_match = re.search(r'(?:month|·ãà·à≠)[:\\s]+(\\w+)', user_lower,\n                                re.UNICODE)\n        if month_match:\n            explicit_month = month_match.group(1)\n            logger.info(f\"‚úì Explicit month label found: {explicit_month}\")\n\n    # Extract house number with priority:\n    # 1. Explicit house label (edit mode only)\n    # 2. User-typed text (highest priority - explicit house number)\n    # 3. Caption\n    # 4. Combined text (lowest priority - may contain false positives from OCR)\n    #    BUT: Skip combined text in edit mode if user sent bare number (it's for amount, not house)\n    house_number = \"\"\n    is_bare_number = False\n\n    if explicit_house:\n        # User explicitly labeled this as house number\n        house_number = explicit_house\n        logger.info(f\"Using explicit house number: {house_number}\")\n    elif is_edit_mode and user_text:\n        # ========== EDIT MODE: BARE NUMBER DISAMBIGUATION ==========\n        # Check if user text is JUST a number (bare number)\n        user_stripped = user_text.strip()\n        bare_number_match = re.match(r'^[0-9.]+$', user_stripped)\n\n        if bare_number_match or explicit_amount or explicit_month:\n            # Bare number, explicit amount, or explicit month in edit mode\n            # Do NOT extract house number from user text\n            is_bare_number = True\n            if bare_number_match:\n                logger.info(\n                    f\"‚ö†Ô∏è EDIT MODE: Bare number '{user_stripped}' detected - treating as AMOUNT, not house\"\n                )\n            elif explicit_amount:\n                logger.info(\n                    f\"‚ö†Ô∏è EDIT MODE: Explicit amount detected - NOT extracting house from user text\"\n                )\n            elif explicit_month:\n                logger.info(\n                    f\"‚ö†Ô∏è EDIT MODE: Explicit month detected - NOT extracting house from user text\"\n                )\n\n            # Use original house number from last submission\n            if original_data and original_data.get('house_number'):\n                house_number = original_data['house_number']\n                logger.info(f\"‚úì Keeping original house number: {house_number}\")\n        else:\n            # Not a bare number or explicit field - proceed with normal house extraction\n            logger.info(\"Checking user-typed text for house number...\")\n            house_number = extract_house_from_caption(user_text)\n    elif user_text:\n        # Normal mode - extract house normally\n        logger.info(\"Checking user-typed text for house number...\")\n        house_number = extract_house_from_caption(user_text)\n\n    # Only check caption and combined if not already found AND not a bare number in edit mode\n    if not house_number and caption and not (is_edit_mode and is_bare_number):\n        logger.info(\"Checking caption for house number...\")\n        house_number = extract_house_from_caption(caption)\n\n    if not house_number and not (is_edit_mode and is_bare_number):\n        logger.info(\"Checking combined text for house number...\")\n        house_number = extract_house_from_caption(combined)\n\n    # Extract other fields from all combined content\n    # In edit mode with explicit amount or bare number, use that\n    if explicit_amount:\n        amount = explicit_amount\n        logger.info(f\"Using explicit amount: {amount}\")\n    elif is_edit_mode and user_text:\n        # Check for bare number - treat as amount\n        user_stripped = user_text.strip()\n        bare_number_match = re.match(r'^[0-9.]+$', user_stripped)\n        if bare_number_match:\n            amount = user_stripped\n            logger.info(f\"‚úì EDIT MODE: Using bare number '{amount}' as amount\")\n        else:\n            amount = extract_amount_from_receipt(combined)\n    else:\n        amount = extract_amount_from_receipt(combined)\n\n    date_str = extract_date_from_receipt(combined)\n    \n    # Tiered TxID extraction: user text -> OCR\n    txid = \"\"\n    if user_text:\n        # First, try to extract TxID from user's typed message\n        txid_patterns = [\n            r'(?:txid|transaction\\s*id|tx\\s*id|reference|ref)[:\\s]+([A-Z0-9]{8,})',\n            r'([0-9]{2}[A-Z]{2,}[A-Z0-9]{6,})',  # Pattern like 10BBETF53170884\n        ]\n        for pattern in txid_patterns:\n            match = re.search(pattern, user_text, re.IGNORECASE)\n            if match:\n                txid = match.group(1).upper()\n                logger.info(f\"‚úì TxID from user text: {txid}\")\n                break\n    \n    # Fallback to OCR if not found in user text\n    if not txid:\n        txid = extract_txid_from_receipt(combined)\n    \n    name = extract_name_from_receipt(combined)\n\n    # House mapping\n    try:\n        if house_number in house_map:\n            name = house_map[house_number]\n            logger.info(f\"‚úì Name (mapped): {name}\")\n    except Exception as e:\n        logger.error(f\"Error in house mapping: {e}\")\n\n    # Reason\n    reason = 'other'\n    try:\n        text_lower = combined.lower()\n        for r, keywords in PAYMENT_REASONS.items():\n            for kw in keywords:\n                if kw.lower() in text_lower or kw in combined:\n                    reason = r\n                    break\n            if reason != 'other':\n                break\n        logger.info(f\"‚úì Reason: {reason}\")\n    except Exception as e:\n        logger.error(f\"Error in reason extraction: {e}\")\n\n    # Month - PRIORITIZE user-typed text, then caption, then receipt\n    # 1. Explicit month label (edit mode only)\n    # 2. User-typed text (highest priority - user says \"for month this\")\n    # 3. Caption (medium priority - user adds month in caption)\n    # 4. Combined text (fallback - from receipt)\n    month = \"\"\n\n    if explicit_month:\n        # User explicitly labeled this as month\n        month = convert_to_ethiopian_month(explicit_month)\n        logger.info(f\"Using explicit month: {month}\")\n    elif is_edit_mode and user_text:\n        # In edit mode, skip month extraction if it's just a bare number\n        user_stripped = user_text.strip()\n        bare_number_match = re.match(r'^[0-9.]+$', user_stripped)\n        if not bare_number_match:\n            # Not a bare number, try to extract month\n            logger.info(\"Checking user-typed text for month...\")\n            month = convert_to_ethiopian_month(user_text)\n    elif user_text:\n        logger.info(\"Checking user-typed text for month...\")\n        month = convert_to_ethiopian_month(user_text)\n\n    if not month and caption:\n        logger.info(\"Month not in user text, checking caption...\")\n        month = convert_to_ethiopian_month(caption)\n\n    if not month:\n        logger.info(\"Month not in user text or caption, checking receipt...\")\n        month = convert_to_ethiopian_month(combined)\n\n    # Extract beneficiary (who received the payment)\n    beneficiary = \"\"\n    try:\n        logger.info(\"Starting beneficiary extraction...\")\n        beneficiary = extract_beneficiary_from_receipt(combined)\n        logger.info(f\"Beneficiary extraction complete: '{beneficiary}'\")\n    except Exception as e:\n        logger.error(f\"‚ùå CRITICAL: Error in beneficiary extraction: {e}\", exc_info=True)\n\n    logger.info(f\"=== EXTRACTION COMPLETE ===\")\n    logger.info(\n        f\"House={house_number}, Amount={amount}, Name={name}, Month={month} (Ethiopian), Beneficiary={beneficiary}\"\n    )\n\n    return {\n        'house_number': house_number,\n        'amount': amount,\n        'payment_date': date_str,\n        'transaction_id': txid,\n        'name': name,\n        'reason': reason,\n        'month': month,\n        'beneficiary': beneficiary\n    }\n\n\n# ========== MESSAGE BUFFERING AND PROCESSING ==========\n\n# Track message thread ID for each user (for proper replies)\nuser_thread_ids = {}\n\n# Track buffered message IDs for deletion detection\nuser_buffered_message_ids = defaultdict(dict)  # {chat_id: {user_id: [message_ids]}}\n\n\nasync def delete_message_after(message, delay_seconds: int):\n    \"\"\"Delete a message after specified delay in seconds\"\"\"\n    try:\n        await asyncio.sleep(delay_seconds)\n        await message.delete()\n        logger.info(f\"‚úì Auto-deleted message after {delay_seconds}s\")\n    except Exception as e:\n        logger.error(f\"Error deleting message: {e}\")\n\n\nasync def check_message_exists(bot, chat_id: int, message_id: int) -> bool:\n    \"\"\"Check if a message still exists (wasn't deleted by user)\"\"\"\n    try:\n        # Try to forward the message to nowhere - this will fail if message doesn't exist\n        # Actually, use getMessage is not available in python-telegram-bot\n        # Instead, try to copy the message - this will fail if deleted\n        # Actually the best approach is to try to get message reactions or pin it briefly\n        # Simplest: try to edit or react to it - if it fails with \"message not found\", it was deleted\n        \n        # For efficiency, we can try to forward message to same chat (which will fail if deleted)\n        # But this is noisy. Better approach: track message existence differently\n        \n        # Alternative: Use getUpdates or message.forward() test\n        # Most reliable: Try to set a reaction and catch the error\n        return True  # We'll check during actual processing with safer method\n    except Exception as e:\n        logger.warning(f\"Message {message_id} in chat {chat_id} may have been deleted: {e}\")\n        return False\n\n\nasync def verify_buffered_messages_exist(bot, chat_id: int, user_id: int, messages: list) -> list:\n    \"\"\"Verify which buffered messages still exist and return only valid ones\"\"\"\n    valid_messages = []\n    for msg_data in messages:\n        msg = msg_data.get('message')\n        if msg:\n            try:\n                # Try to get the message - if it was deleted, this will fail\n                # Actually, we can't directly check if a message exists\n                # But we can check if we can still reply to it\n                # The safest approach is to try a benign operation\n                \n                # Check if message_id is still accessible by trying to get file if photo\n                # For now, we'll add the message and handle errors during reply\n                valid_messages.append(msg_data)\n            except Exception as e:\n                logger.info(f\"‚è≠Ô∏è Skipping deleted message from user {user_id}: {e}\")\n        else:\n            valid_messages.append(msg_data)\n    return valid_messages\n\n\nasync def safe_reply_text(message, text, **kwargs):\n    \"\"\"Safely send a reply to a message, handling deleted messages gracefully\"\"\"\n    try:\n        return await message.reply_text(text, **kwargs)\n    except BadRequest as e:\n        if \"message to be replied not found\" in str(e).lower() or \"message not found\" in str(e).lower():\n            logger.warning(f\"Cannot reply to message (message was deleted): {e}\")\n            return None\n        else:\n            raise\n    except Exception as e:\n        logger.error(f\"Error sending reply: {e}\")\n        raise\n\n\nasync def expire_edit_mode(user_id: int, chat_id: int, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Expire edit mode after timeout if no messages received\"\"\"\n    await asyncio.sleep(EDIT_MODE_DELAY)\n\n    # Check if user is still in edit mode and has no buffered messages\n    # Check both key absence and empty list (defaultdict creates empty lists)\n    has_no_messages = (chat_id not in user_message_buffers\n                       or user_id not in user_message_buffers[chat_id]\n                       or not user_message_buffers[chat_id][user_id])\n\n    if user_edit_mode.get(chat_id, {}).get(user_id) and has_no_messages:\n        logger.info(f\"‚è∞ Edit mode expired for user {user_id} in chat {chat_id}\")\n        del user_edit_mode[chat_id][user_id]\n\n        # Notify user that edit mode expired (use their specific thread ID)\n        try:\n            # Get the user's thread ID (where they last sent a message)\n            thread_id = user_thread_ids.get(user_id)\n            \n            # Only send notification if we have a valid thread ID for this user\n            if thread_id:\n                sent_msg = await context.bot.send_message(\n                    chat_id=chat_id,\n                    message_thread_id=thread_id,\n                    text=\n                    f\"‚è∞ ·ã®·àõ·àµ·â∞·ä´·ä®·ã´ ·åä·ãú ·ä®{EDIT_MODE_DELAY} ·à∞·ä®·äï·ã∂·âΩ ·â†·äã·àã ·ä†·àç·âã·àç·ç¢\\n·ä•·äï·ã∞·åà·äì ·àà·àõ·àµ·â∞·ä´·ä®·àç /edit ·â•·àà·ãç ·ã≠·åª·çâ ·ãà·ã≠·àù ·ã≠·å´·äë·âµ·ç¢\"\n                )\n                # Auto-delete this notification message after 60 seconds\n                asyncio.create_task(delete_message_after(sent_msg, 60))\n            else:\n                logger.warning(f\"No thread ID found for user {user_id}, skipping expiry notification\")\n        except Exception as e:\n            logger.error(\n                f\"Error notifying user {user_id} about edit mode expiry: {e}\")\n\n    # Clean up task reference\n    if chat_id in user_edit_mode_tasks and user_id in user_edit_mode_tasks[chat_id]:\n        del user_edit_mode_tasks[chat_id][user_id]\n\n\nasync def process_buffered_messages(user_id: int,\n                                    chat_id: int,\n                                    context: ContextTypes.DEFAULT_TYPE,\n                                    is_edit_mode: bool = False):\n    \"\"\"Process all buffered messages from a user after delay\"\"\"\n    delay = EDIT_MODE_DELAY if is_edit_mode else MESSAGE_BUFFER_DELAY\n    await asyncio.sleep(delay)\n\n    if chat_id not in user_message_buffers or user_id not in user_message_buffers[chat_id] or not user_message_buffers[chat_id][user_id]:\n        return\n\n    # Check if any buffered messages were deleted during the wait\n    # We'll check by attempting to copy the message - if deleted, it will fail\n    valid_messages = []\n    deleted_count = 0\n    \n    for msg_data in user_message_buffers[chat_id][user_id]:\n        msg = msg_data.get('message')\n        if msg:\n            try:\n                # Try to copy message to check if it exists (will fail if deleted)\n                copied = await context.bot.copy_message(\n                    chat_id=chat_id,\n                    from_chat_id=chat_id,\n                    message_id=msg.message_id,\n                    disable_notification=True\n                )\n                # Delete the copied message immediately\n                try:\n                    await context.bot.delete_message(chat_id=chat_id, message_id=copied.message_id)\n                except:\n                    pass\n                valid_messages.append(msg_data)\n            except BadRequest as e:\n                error_str = str(e).lower()\n                if \"not found\" in error_str or \"deleted\" in error_str:\n                    logger.info(f\"‚è≠Ô∏è Message {msg.message_id} was deleted by user {user_id}, skipping\")\n                    deleted_count += 1\n                    continue\n                else:\n                    # Other error, assume message exists\n                    valid_messages.append(msg_data)\n            except Exception as e:\n                # On any other error, assume message exists and continue\n                valid_messages.append(msg_data)\n        else:\n            valid_messages.append(msg_data)\n    \n    # If all messages were deleted, abort processing silently\n    if not valid_messages:\n        logger.info(f\"‚è≠Ô∏è All {deleted_count} buffered messages from user {user_id} were deleted, aborting\")\n        user_message_buffers[chat_id][user_id].clear()\n        if chat_id in user_message_buffers and user_id in user_message_buffers[chat_id]:\n            del user_message_buffers[chat_id][user_id]\n        if chat_id in user_buffer_tasks and user_id in user_buffer_tasks[chat_id]:\n            del user_buffer_tasks[chat_id][user_id]\n        return\n    \n    # If some messages were deleted, log it\n    if deleted_count > 0:\n        logger.info(f\"‚è≠Ô∏è {deleted_count} message(s) deleted by user {user_id}, continuing with {len(valid_messages)} remaining\")\n    \n    # Update buffer with only valid messages\n    user_message_buffers[chat_id][user_id] = valid_messages\n\n    logger.info(\n        f\"üîÑ Processing {len(user_message_buffers[chat_id][user_id])} buffered messages from user {user_id} in chat {chat_id}\"\n    )\n\n    # Separate OCR text from user-typed text\n    ocr_text = []\n    user_text = []\n    combined_caption = []\n    reply_msg = None\n\n    for msg_data in user_message_buffers[chat_id][user_id]:\n        if msg_data['text']:\n            if msg_data['is_ocr']:\n                ocr_text.append(msg_data['text'])\n            else:\n                user_text.append(msg_data['text'])\n        if msg_data['caption']:\n            combined_caption.append(msg_data['caption'])\n        if reply_msg is None:\n            reply_msg = msg_data['message']  # Use first message for replies\n\n    all_user_text = \" \".join(\n        user_text)  # User-typed messages (space separated)\n    all_ocr_text = \"\\n\".join(ocr_text)  # OCR text (line separated)\n    all_captions = \" \".join(combined_caption)\n    all_combined = all_user_text + \"\\n\" + all_ocr_text  # Combined for other extractions\n\n    logger.info(\n        f\"User text: {len(all_user_text)} chars, OCR: {len(all_ocr_text)} chars, Captions: {len(all_captions)} chars\"\n    )\n\n    # Get original data if in edit mode\n    original_data = None\n    if is_edit_mode and user_last_submissions.get(chat_id, {}).get(user_id):\n        original_data = user_last_submissions[chat_id][user_id]['data']\n\n    # Extract payment data - pass edit mode flag for disambiguation\n    try:\n        logger.info(\"About to call extract_payment_data_buffered...\")\n        data = extract_payment_data_buffered(all_combined,\n                                             all_captions,\n                                             all_user_text,\n                                             is_edit_mode=is_edit_mode,\n                                             original_data=original_data,\n                                             chat_id=chat_id)\n        logger.info(\"extract_payment_data_buffered completed successfully\")\n    except Exception as e:\n        logger.error(f\"‚ùå CRITICAL ERROR in extract_payment_data_buffered: {e}\", exc_info=True)\n        if reply_msg:\n            error_msg = await safe_reply_text(reply_msg, f\"‚ùå ·ã®·àò·à®·åÉ ·àµ·àÖ·â∞·âµ\\nError extracting payment data: {str(e)}\")\n            if error_msg:\n                asyncio.create_task(delete_message_after(error_msg, 180))\n        user_message_buffers[chat_id][user_id].clear()\n        if chat_id in user_message_buffers and user_id in user_message_buffers[chat_id]:\n            del user_message_buffers[chat_id][user_id]\n        if chat_id in user_buffer_tasks and user_id in user_buffer_tasks[chat_id]:\n            del user_buffer_tasks[chat_id][user_id]\n        return\n\n    # ========== EDIT MODE HANDLING ==========\n    if is_edit_mode and user_last_submissions.get(chat_id, {}).get(user_id):\n        logger.info(\n            f\"üîÑ EDIT MODE: Processing as complete replacement (no merging)\")\n        logger.info(f\"üîÑ NEW COMPLETE DATA: {data}\")\n\n    # Validate amount is present\n    if not data['amount']:\n        if reply_msg:\n            # Create inline keyboard with Edit Again button\n            keyboard = [[\n                InlineKeyboardButton(\"·ä•·äï·ã∞·åà·äì ·àç·àã·ä≠ ‚úèÔ∏è\",\n                                     callback_data=f\"edit_{user_id}\")\n            ]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n\n            # Add failure reaction to original message\n            try:\n                await reply_msg.set_reaction(\"üëé\")\n            except Exception as e:\n                logger.warning(f\"Could not add reaction: {e}\")\n            \n            warning_msg = await safe_reply_text(reply_msg,\n                f\"‚ö†Ô∏è ·ã®·àã·ä©·âµ ·àò·à®·åÉ ·âµ·ä≠·ä≠·àà·äõ/·ã®·â∞·àü·àã ·ä†·ã´·ã∞·àà·àù\\n\\n\"\n                f\"·ã®·â∞·àò·ãò·åà·â† ·àò·à®·åÉ:\\n\"\n                f\"üè† ·â§·âµ: {data['house_number'] or '‚Äî'}\\n\"\n                f\"üí∞ ·àò·å†·äï: {data['amount'] or '‚Äî'} ·â•·à≠\\n\"\n                f\"üë§ ·àµ·àù: {data['name'] or '‚Äî'}\\n\"\n                f\"üìÖ ·âÄ·äï: {data['payment_date'] or '‚Äî'}\\n\\n\"\n                f\" ·ä®·àã·ã≠ ·ã®·àö·àò·àà·ä®·â±·âµ ·àò·à®·åÉ ·âµ·ä≠·ä≠·àç ·ä†·ã≠·ã∞·àà·àù‚ùì\\n\"\n                f\"·àô·àâ·ãç·äï·äì ·ã®·â∞·àµ·â∞·ä´·ä®·àà·ãç·äï ·àò·à®·åÉ ·ä•·äï·ã∞·åà·äì ·àà·àò·àã·ä≠ '·ä•·äï·ã∞·åà·äì ·àç·àã·ä≠' ·ã®·àö·àà·ãç·äï ·ã≠·å´·äë·ç¢\",\n                reply_markup=reply_markup)\n            # Auto-delete warning message after 10 minutes\n            if warning_msg:\n                asyncio.create_task(delete_message_after(warning_msg, 600))\n        user_message_buffers[chat_id][user_id].clear()\n        # Delete the key to ensure expire_edit_mode timeout can fire properly\n        if chat_id in user_message_buffers and user_id in user_message_buffers[chat_id]:\n            del user_message_buffers[chat_id][user_id]\n        if chat_id in user_buffer_tasks and user_id in user_buffer_tasks[chat_id]:\n            del user_buffer_tasks[chat_id][user_id]\n        if user_edit_mode.get(chat_id, {}).get(user_id):\n            del user_edit_mode[chat_id][user_id]\n        return\n\n    # ========== BENEFICIARY VALIDATION ==========\n    # Validate that payment was sent to the correct account\n    beneficiary = data.get('beneficiary', '')\n    is_valid_beneficiary, normalized_beneficiary = validate_beneficiary(beneficiary)\n    \n    if not is_valid_beneficiary:\n        logger.warning(f\"‚ùå WRONG BENEFICIARY DETECTED: '{normalized_beneficiary}'\")\n        if reply_msg:\n            # Create inline keyboard with Edit Again button\n            keyboard = [[\n                InlineKeyboardButton(\"·ä•·äï·ã∞·åà·äì ·àç·àã·ä≠ ‚úèÔ∏è\",\n                                     callback_data=f\"edit_{user_id}\")\n            ]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n\n            # Add failure reaction to original message\n            try:\n                await reply_msg.set_reaction(\"üëé\")\n            except Exception as e:\n                logger.warning(f\"Could not add reaction: {e}\")\n            \n            # Different messages for missing vs wrong beneficiary\n            if not beneficiary:\n                error_msg = await safe_reply_text(reply_msg,\n                    f\"‚ö†Ô∏è ·ã®·â∞·âÄ·â£·ã© ·àò·à®·åÉ ·ä†·àç·â∞·åà·äò·àù!\\n\"\n                    f\"‚ùå Cannot Verify Payment Account\\n\\n\"\n                    f\"The beneficiary/receiver name could not be found on the receipt.\\n\"\n                    f\"Please verify the receipt shows payment was sent to:\\n\\n\"\n                    f\"‚úÖ Expected account:\\n\"\n                    f\"   SEYOUM ASSEFA and/or SENAIT DAGNIE\\n\\n\"\n                    f\"If the receipt is unclear, please contact @sphinxlike for manual verification.\",\n                    reply_markup=reply_markup)\n            else:\n                error_msg = await safe_reply_text(reply_msg,\n                    f\"‚ö†Ô∏è ·åà·äï·ãò·â° ·ãà·ã∞ ·â∞·à≥·à≥·â∞ ·ä†·ä´·ãç·äï·âµ ·â∞·àç·ä≥·àç!\\n\"\n                    #f\"‚ùå Wrong Beneficiary Detected\\n\\n\"\n                   # f\"üìù Detected beneficiary: {beneficiary}\\n\\n\"\n                    #f\"‚úÖ Expected account:\\n\"\n                    #f\"   SEYOUM ASSEFA and/or SENAIT DAGNIE\\n\\n\"\n                    f\"Please verify the receipt and make sure the payment was sent to the correct account.\",\n                    reply_markup=reply_markup)\n            # Auto-delete error message after 3 minutes\n            if error_msg:\n                asyncio.create_task(delete_message_after(error_msg, 180))\n        \n        # Clean up and exit without saving\n        user_message_buffers[chat_id][user_id].clear()\n        if chat_id in user_message_buffers and user_id in user_message_buffers[chat_id]:\n            del user_message_buffers[chat_id][user_id]\n        if chat_id in user_buffer_tasks and user_id in user_buffer_tasks[chat_id]:\n            del user_buffer_tasks[chat_id][user_id]\n        if user_edit_mode.get(chat_id, {}).get(user_id):\n            del user_edit_mode[chat_id][user_id]\n        return\n\n    # Save to Google Sheets\n    reason = data['reason']\n    logger.info(f\"üîÑ Attempting to save to Google Sheets - Reason: {reason}\")\n    \n    try:\n        sheets = setup_sheets(chat_id)\n        logger.info(f\"‚úì Sheets setup successful: {list(sheets.keys()) if sheets else 'None'}\")\n    except Exception as e:\n        logger.error(f\"‚ùå CRITICAL: Failed to setup Google Sheets: {e}\", exc_info=True)\n        if reply_msg:\n            error_msg = await safe_reply_text(reply_msg, f\"‚ùå ·àµ·àÖ·â∞·âµ ·â†Google Sheets ·ä†·åà·àç·åç·àé·âµ\\nError: {str(e)}\")\n            if error_msg:\n                asyncio.create_task(delete_message_after(error_msg, 600))\n        return\n    \n    target_sheet = sheets.get(reason) if sheets else None\n\n    if target_sheet:\n        try:\n            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n            # Convert amount to float to ensure it's stored as a number\n            try:\n                amount_value = float(data['amount']) if data['amount'] else 0\n            except:\n                amount_value = data[\n                    'amount']  # Fallback to original if conversion fails\n\n            house_number = data['house_number']\n            month = data['month']\n            txid = data['transaction_id'] or ''\n            \n            # Find the row for this house number\n            all_values = target_sheet.get_all_values()\n            row_index = None\n            \n            for idx, row in enumerate(all_values[2:], start=3):  # Skip 2 header rows, data starts at row 3\n                if len(row) > 1 and row[1].strip() == house_number.strip():  # Column B (H.No) - trim whitespace\n                    row_index = idx\n                    break\n            \n            if not row_index:\n                logger.error(f\"House {house_number} not found in sheet {reason}\")\n                if reply_msg:\n                    error_msg = await safe_reply_text(reply_msg, f\"‚ùå ·â§·âµ {house_number} ·â†·ãù·à≠·ãù·à≠ ·ãç·àµ·å• ·ä†·àç·â∞·åà·äò·àù\")\n                    if error_msg:\n                        asyncio.create_task(delete_message_after(error_msg, 600))\n                return\n            \n            # Find the column for the month (need this BEFORE duplicate check)\n            if month not in ETHIOPIAN_MONTHS:\n                logger.warning(f\"Month '{month}' not recognized\")\n            \n            month_index = ETHIOPIAN_MONTHS.index(month) if month in ETHIOPIAN_MONTHS else -1\n            \n            if month_index == -1:\n                logger.error(f\"Cannot find column for month '{month}'\")\n                if reply_msg:\n                    error_msg = await safe_reply_text(reply_msg, f\"‚ùå ·ãà·à© '{month}' ·ä†·àç·â≥·ãà·âÄ·àù\")\n                    if error_msg:\n                        asyncio.create_task(delete_message_after(error_msg, 600))\n                return\n            \n            # Calculate column positions for this month (2 columns per month: Amount, FT No)\n            # Columns: No (A=0), H.No (B=1), Name (C=2), then 2 columns per month\n            # Amount column = 3 + (month_index * 2)\n            # FT No column  = 3 + (month_index * 2) + 1\n            amount_col_idx = 3 + (month_index * 2)\n            ftno_col_idx = amount_col_idx + 1\n            \n            # ========== DUPLICATE TRANSACTION ID CHECK ==========\n            # Only check for duplicates if transaction ID exists\n            # (Without TxID, we allow multiple payments to support partial/split payments)\n            if txid and txid.strip():\n                logger.info(f\"üîç Checking for duplicate transaction ID: {txid} across ALL sheets\")\n                logger.info(f\"   Current cell to skip: row={row_index}, col={ftno_col_idx} in sheet '{reason}'\")\n                duplicate_found = False\n                duplicate_sheet = None\n                duplicate_row = None\n                \n                # Check ALL sheets, not just the current one\n                for sheet_reason, sheet in sheets.items():\n                    sheet_values = sheet.get_all_values()\n                    \n                    for idx, row in enumerate(sheet_values[2:], start=3):  # Skip 2 header rows\n                        # Check all FT No columns (every even column starting from column E=4)\n                        for col_idx in range(4, len(row), 2):  # Start at 4 (column E), step by 2\n                            # Skip the current cell being updated (allows edits on the active sheet)\n                            if sheet_reason == reason and idx == row_index and col_idx == ftno_col_idx:\n                                logger.info(f\"   Skipping current cell: row={idx}, col={col_idx} in sheet '{sheet_reason}'\")\n                                continue\n                            \n                            if len(row) > col_idx:\n                                cell_value = row[col_idx].strip()\n                                if cell_value:\n                                    existing_txids = [t.strip() for t in cell_value.split(',')]\n                                    if txid.strip() in existing_txids:\n                                        duplicate_found = True\n                                        duplicate_sheet = sheet_reason\n                                        duplicate_row = idx\n                                        logger.warning(f\"‚ùå DUPLICATE TRANSACTION ID DETECTED: {txid} found in sheet '{sheet_reason}' at row {idx}, col {col_idx}\")\n                                        break\n                        if duplicate_found:\n                            break\n                    if duplicate_found:\n                        break\n                \n                if duplicate_found:\n                    # Display Amharic message and don't save\n                    reason_display = PAYMENT_REASONS_AMHARIC.get(duplicate_sheet, duplicate_sheet.capitalize())\n                    if reply_msg:\n                        # Create inline keyboard with Edit Again button\n                        keyboard = [[\n                            InlineKeyboardButton(\"·ä•·äï·ã∞·åà·äì ·àç·àã·ä≠ ‚úèÔ∏è\",\n                                                 callback_data=f\"edit_{user_id}\")\n                        ]]\n                        reply_markup = InlineKeyboardMarkup(keyboard)\n                        \n                        # Add failure reaction to original message\n                        try:\n                            await reply_msg.set_reaction(\"‚ö†Ô∏è\")\n                        except Exception as e:\n                            logger.warning(f\"Could not add reaction: {e}\")\n                        \n                        error_msg = await safe_reply_text(reply_msg,\n                            f\"‚ö†Ô∏è ·ã≠·àÖ ·ã∞·à®·à∞·äù ·ä®·ãö·àÖ ·â†·çä·âµ ·â∞·àç·ä≥·àç ·ä•·äì ·â∞·àò·ãù·åç·âß·àç\\n\\n\"\n                            f\"This receipt has been sent before and recorded.\\n\\n\"\n                            f\"üîñ Transaction ID: {txid}\\n\"\n                            f\"üìã Found in: {reason_display} (row {duplicate_row})\",\n                            reply_markup=reply_markup)\n                        \n                        # Auto-delete error message after 3 minutes\n                        if error_msg:\n                            asyncio.create_task(delete_message_after(error_msg, 180))\n                    \n                    # Clean up and exit without saving\n                    user_message_buffers[chat_id][user_id].clear()\n                    if chat_id in user_message_buffers and user_id in user_message_buffers[chat_id]:\n                        del user_message_buffers[chat_id][user_id]\n                    if chat_id in user_buffer_tasks and user_id in user_buffer_tasks[chat_id]:\n                        del user_buffer_tasks[chat_id][user_id]\n                    if user_edit_mode.get(chat_id, {}).get(user_id):\n                        del user_edit_mode[chat_id][user_id]\n                    return\n                else:\n                    logger.info(f\"‚úÖ No duplicate found for transaction ID: {txid} across all sheets\")\n            else:\n                logger.info(f\"‚ö†Ô∏è No transaction ID provided - allowing multiple submissions (supports partial payments)\")\n            # ========== END DUPLICATE CHECK ==========\n            \n            # Convert column index to letter (A=0, B=1, C=2, D=3, etc.)\n            def col_idx_to_letter(idx):\n                result = ''\n                while idx >= 0:\n                    result = chr(65 + (idx % 26)) + result\n                    idx = idx // 26 - 1\n                return result\n            \n            amount_col = col_idx_to_letter(amount_col_idx)\n            ftno_col = col_idx_to_letter(ftno_col_idx)\n            \n            # Read current values from the cells\n            # For amounts, we need the actual formula if it exists (not just the calculated value)\n            try:\n                # Get the actual formula from the cell\n                amount_cell = f'{col_idx_to_letter(amount_col_idx)}{row_index}'\n                cell_data = target_sheet.acell(amount_cell, value_render_option='FORMULA')\n                current_amount = cell_data.value.strip() if cell_data.value else ''\n                # Remove leading '=' if it's a formula\n                if current_amount.startswith('='):\n                    current_amount = current_amount[1:]\n            except:\n                # Fallback to regular value if formula fetch fails\n                current_amount = all_values[row_index - 1][amount_col_idx].strip() if len(all_values[row_index - 1]) > amount_col_idx else ''\n            \n            current_txid = all_values[row_index - 1][ftno_col_idx].strip() if len(all_values[row_index - 1]) > ftno_col_idx else ''\n            \n            # Determine final values based on mode and existing data\n            if is_edit_mode:\n                # In edit mode, remove the user's previous contribution and add the new one\n                # Get the user's last submission data to know what to remove\n                last_submission = user_last_submissions.get(chat_id, {}).get(user_id, {})\n                if last_submission:\n                    old_amount = str(last_submission['data'].get('amount', ''))\n                    old_txid = last_submission['data'].get('transaction_id', '')\n                    \n                    # Remove old contribution from current values\n                    if old_amount and current_amount:\n                        # Remove the old amount part (handles both \"500\" and \"500+300\" cases)\n                        amount_parts = current_amount.split('+')\n                        amount_parts = [p.strip() for p in amount_parts if p.strip() != old_amount.strip()]\n                        remaining_amount = '+'.join(amount_parts) if amount_parts else ''\n                    else:\n                        remaining_amount = current_amount\n                    \n                    if old_txid and current_txid:\n                        # Remove the old txid part\n                        txid_parts = [p.strip() for p in current_txid.split(',')]\n                        txid_parts = [p for p in txid_parts if p.strip() != old_txid.strip()]\n                        remaining_txid = ', '.join(txid_parts) if txid_parts else ''\n                    else:\n                        remaining_txid = current_txid\n                    \n                    # Now add the new values\n                    if remaining_amount:\n                        final_amount = f\"{remaining_amount}+{amount_value}\"\n                    else:\n                        final_amount = amount_value\n                    \n                    if remaining_txid:\n                        final_txid = f\"{remaining_txid}, {txid}\"\n                    else:\n                        final_txid = txid\n                    \n                    logger.info(f\"Edit mode: Replaced {old_amount}/{old_txid} with {amount_value}/{txid}\")\n                else:\n                    # No previous submission found, treat as new\n                    final_amount = amount_value\n                    final_txid = txid\n            else:\n                # In normal mode, append to existing values if they exist\n                if current_amount and current_amount != '':\n                    # Append amount with + separator\n                    final_amount = f\"{current_amount}+{amount_value}\"\n                    logger.info(f\"Appending amount: {current_amount} + {amount_value} = {final_amount}\")\n                else:\n                    final_amount = amount_value\n                \n                if current_txid and current_txid != '':\n                    # Append transaction ID with comma separator\n                    final_txid = f\"{current_txid}, {txid}\"\n                    logger.info(f\"Appending txid: {current_txid}, {txid}\")\n                else:\n                    final_txid = txid\n            \n            # Prepare final amount for Google Sheets\n            # If it contains '+', make it a formula so SUM works in TOTALS row\n            if isinstance(final_amount, str) and '+' in final_amount:\n                final_amount_for_sheet = f\"={final_amount}\"\n                logger.info(f\"Converting to formula: {final_amount_for_sheet}\")\n            else:\n                final_amount_for_sheet = final_amount\n            \n            # Update Amount column\n            target_sheet.update(f'{amount_col}{row_index}', [[final_amount_for_sheet]], \n                              value_input_option='USER_ENTERED')\n            \n            # Update FT No column (keep as text, not formula)\n            target_sheet.update(f'{ftno_col}{row_index}', [[final_txid]], \n                              value_input_option='USER_ENTERED')\n            \n            logger.info(f\"‚úì Updated {reason} - House {house_number}, Month {month} at row {row_index}, cols {amount_col}/{ftno_col}\")\n\n            # Store last submission for edit mode (with row index and month info)\n            user_last_submissions[chat_id][user_id] = {\n                'data': data.copy(),\n                'sheet_name': reason,\n                'timestamp': timestamp,\n                'row_index': row_index,\n                'month': month,\n                'amount_col': amount_col,\n                'ftno_col': ftno_col\n            }\n\n            if reply_msg:\n                # Create inline keyboard with Edit button and History button\n                keyboard = [\n                    [\n                        InlineKeyboardButton(\"·ä•·äï·ã∞·åà·äì ·àç·àã·ä≠ ‚úèÔ∏è\",\n                                             callback_data=f\"edit_{user_id}\"),\n                        InlineKeyboardButton(\"·â≥·à™·ä≠ üìã\",\n                                             callback_data=f\"history_{user_id}_{data['house_number']}\")\n                    ]\n                ]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n\n                # Different message for edit vs new\n                if is_edit_mode:\n                    message_text = f\"‚úÖ ·â∞·àµ·â∞·ä´·ä≠·àè·àç!\\n\\n\"\n                else:\n                    message_text = f\"‚úÖ ·â∞·àò·ãù·åç·âß·àç!\\n\\n\"\n\n                # Convert month and reason to Amharic for display\n                month_display = ETHIOPIAN_MONTHS_AMHARIC.get(data['month'], data['month'])\n                reason_display = PAYMENT_REASONS_AMHARIC.get(reason, reason.capitalize())\n                \n                message_text += (f\"üè† ·â§·âµ: {data['house_number'] or '‚Äî'}\\n\"\n                                 f\"üë§ ·àµ·àù: {data['name'] or '‚Äî'}\\n\"\n                                 f\"üí∞ ·àò·å†·äï: {data['amount']} ·â•·à≠\\n\"\n                                 f\"üìÜ ·ãà·à≠: {month_display or '‚Äî'}\\n\"\n                                 f\"üîñ T: {data['transaction_id'] or '‚Äî'}\\n\"\n                                 f\"üìä ·àù·ä≠·äï·ã´·âµ: {reason_display}\")\n\n                # Add success reaction to original message\n                try:\n                    await reply_msg.set_reaction(\"üëç\")\n                except Exception as e:\n                    logger.warning(f\"Could not add reaction: {e}\")\n                \n                # Send message and auto-delete after 10 minutes\n                sent_msg = await safe_reply_text(reply_msg, message_text,\n                                           reply_markup=reply_markup)\n                \n                # Schedule message deletion after 10 minutes (600 seconds)\n                if sent_msg:\n                    asyncio.create_task(delete_message_after(sent_msg, 600))\n        except Exception as e:\n            logger.error(f\"‚ùå CRITICAL: Save to Google Sheets failed: {e}\", exc_info=True)\n            if reply_msg:\n                # Add failure reaction to original message\n                try:\n                    await reply_msg.set_reaction(\"üëé\")\n                except Exception as react_error:\n                    logger.warning(f\"Could not add reaction: {react_error}\")\n                \n                error_msg = await safe_reply_text(reply_msg, f\"‚ùå ·àµ·àÖ·â∞·âµ ·â†·àõ·àµ·âÄ·àò·å• ·àã·ã≠\\nError: {str(e)}\")\n                # Auto-delete error message after 10 minutes\n                if error_msg:\n                    asyncio.create_task(delete_message_after(error_msg, 600))\n    else:\n        if reply_msg:\n            # Add failure reaction to original message\n            try:\n                await reply_msg.set_reaction(\"üëé\")\n            except Exception as e:\n                logger.warning(f\"Could not add reaction: {e}\")\n            \n            error_msg = await safe_reply_text(reply_msg, \"‚ùå ·àµ·àÖ·â∞·âµ ·â†·àò·à®·åÉ - ·â§·âµ\")\n            # Auto-delete error message after 10 minutes\n            if error_msg:\n                asyncio.create_task(delete_message_after(error_msg, 600))\n\n    # Clear buffer and edit mode flag\n    if chat_id in user_message_buffers and user_id in user_message_buffers[chat_id]:\n        user_message_buffers[chat_id][user_id].clear()\n        # Delete the key to ensure expire_edit_mode timeout can fire properly\n        del user_message_buffers[chat_id][user_id]\n    if chat_id in user_buffer_tasks and user_id in user_buffer_tasks[chat_id]:\n        del user_buffer_tasks[chat_id][user_id]\n    if user_edit_mode.get(chat_id, {}).get(user_id):\n        del user_edit_mode[chat_id][user_id]\n        logger.info(f\"‚úì Cleared edit mode for user {user_id} in chat {chat_id}\")\n\n\n# ========== MESSAGE HANDLER ==========\nasync def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    msg = update.effective_message\n    user_id = update.effective_user.id\n    message_id = msg.message_id\n    chat_id = update.effective_chat.id\n    thread_id = msg.message_thread_id if hasattr(msg, 'message_thread_id') else None\n\n    # DEBUG: Log all incoming messages\n    logger.info(f\"üì® Received message - Chat ID: {chat_id}, Thread ID: {thread_id}, User: {user_id}, Message ID: {message_id}\")\n\n    # Create composite key for message tracking (supports multi-group)\n    message_key = (chat_id, message_id, thread_id)\n    \n    # Check if this message has already been processed (for offline scenario)\n    if message_key in processed_message_ids:\n        logger.info(f\"‚è≠Ô∏è Skipping already processed message {message_key}\")\n        return\n    \n    # Mark message as processed and save\n    processed_message_ids.add(message_key)\n    save_processed_messages()\n\n    # Check if admin is in search mode (BEFORE group/topic filters)\n    # Search across all groups where this user might be an admin\n    search_group_id = None\n    for gid in GROUP_CONFIGS.keys():\n        if admin_search_mode.get(gid, {}).get(user_id):\n            search_group_id = admin_search_mode[gid][user_id]\n            break\n    \n    if search_group_id:\n        house_number = (msg.text or \"\").strip()\n\n        # Validate house number (3 or 4 digits)\n        if house_number.isdigit() and len(house_number) in [3, 4]:\n            # Clear search mode for this group\n            for gid in GROUP_CONFIGS.keys():\n                if admin_search_mode.get(gid, {}).get(user_id):\n                    del admin_search_mode[gid][user_id]\n\n            # Create a mock query object for show_house_payments\n            class MockQuery:\n\n                def __init__(self, message):\n                    self.message = message\n\n            await show_house_payments(MockQuery(msg), house_number, search_group_id)\n        else:\n            await msg.reply_text(\n                \"‚ùå Invalid house number. Please send a 3 or 4 digit number.\\n\\n\"\n                \"Example: `507` or `901`\",\n                parse_mode='Markdown')\n        return\n\n    # Group and topic filters (only for payment processing)\n    # Check if message is from a configured group\n    if chat_id not in GROUP_CONFIGS:\n        logger.info(f\"‚è≠Ô∏è Ignoring message from unconfigured group {chat_id}\")\n        return\n    \n    # Get the topic ID for this specific group\n    group_topic_id = GROUP_CONFIGS[chat_id]['topic_id']\n    \n    # Check if message is in the correct topic for this group\n    if group_topic_id and (not hasattr(msg, 'message_thread_id')\n                     or msg.message_thread_id != group_topic_id):\n        logger.info(f\"‚è≠Ô∏è Ignoring message from wrong topic. Expected: {group_topic_id}, Got: {thread_id}\")\n        return\n\n    # Track the thread ID for this user (for proper reply threading)\n    if hasattr(msg, 'message_thread_id') and msg.message_thread_id:\n        user_thread_ids[user_id] = msg.message_thread_id\n\n    text = \"\"\n    caption = msg.caption or \"\"\n    is_ocr = False  # Track if text is from OCR or user-typed\n\n    # Extract text from photo if present\n    if msg.photo:\n        logger.info(f\"üì∏ Processing image from user {user_id}...\")\n\n        try:\n            photo = msg.photo[-1]\n            file = await photo.get_file()\n            image_bytes = await file.download_as_bytearray()\n            text = extract_text_from_image(bytes(image_bytes))\n            is_ocr = True  # Text from OCR\n\n            if not text and not caption:\n                error_msg = await safe_reply_text(msg, \"‚ùå ·â†·àù·àµ·àâ ·àã·ã≠ ·åΩ·àÅ·çç ·ä†·àç·â∞·åà·äò·àù\")\n                if error_msg:\n                    asyncio.create_task(delete_message_after(error_msg, 600))\n                return\n        except Exception as e:\n            logger.error(f\"Image error: {e}\")\n            error_msg = await safe_reply_text(msg, f\"‚ùå ·àµ·àÖ·â∞·âµ: {e}\")\n            if error_msg:\n                asyncio.create_task(delete_message_after(error_msg, 600))\n            return\n    else:\n        text = msg.text or \"\"\n        is_ocr = False  # User-typed text\n\n    if not text and not caption:\n        return\n\n    # Add message to buffer with OCR flag\n    user_message_buffers[chat_id][user_id].append({\n        'text': text,\n        'caption': caption,\n        'is_ocr': is_ocr,\n        'message': msg\n    })\n\n    logger.info(\n        f\"üì• Buffered message from user {user_id} in chat {chat_id} (total: {len(user_message_buffers[chat_id][user_id])})\"\n    )\n\n    # Cancel existing timer if present\n    if chat_id in user_buffer_tasks and user_id in user_buffer_tasks[chat_id]:\n        user_buffer_tasks[chat_id][user_id].cancel()\n        logger.info(f\"‚è±Ô∏è Reset timer for user {user_id} in chat {chat_id}\")\n\n    # Check if user is in edit mode\n    is_edit = user_edit_mode.get(chat_id, {}).get(user_id, False)\n    delay_time = EDIT_MODE_DELAY if is_edit else MESSAGE_BUFFER_DELAY\n\n    # If in edit mode, cancel the edit mode expiry task (user is sending messages)\n    if is_edit and chat_id in user_edit_mode_tasks and user_id in user_edit_mode_tasks[chat_id]:\n        user_edit_mode_tasks[chat_id][user_id].cancel()\n        del user_edit_mode_tasks[chat_id][user_id]\n        logger.info(f\"‚è±Ô∏è Cancelled edit mode expiry timer for user {user_id} in chat {chat_id}\")\n\n    # Start new timer (25s for normal, 60s for edit mode)\n    user_buffer_tasks[chat_id][user_id] = asyncio.create_task(\n        process_buffered_messages(user_id, chat_id, context, is_edit_mode=is_edit))\n\n    logger.info(\n        f\"‚è±Ô∏è Started {delay_time}s timer for user {user_id} (edit_mode={is_edit})\"\n    )\n\n    # Send confirmation (only for first message)\n# if len(user_message_buffers[user_id]) == 1:\n# await msg.reply_text(f\"‚è≥ Waiting {MESSAGE_BUFFER_DELAY}s for more messages...\")\n\n\n# ========== EDIT COMMAND HANDLER ==========\nasync def handle_edit_command(update: Update,\n                              context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Allow users to edit their last submission\"\"\"\n    msg = update.effective_message\n    user_id = update.effective_user.id\n    chat_id = update.effective_chat.id\n\n    # Check if message is from a configured group\n    if chat_id not in GROUP_CONFIGS:\n        return\n    \n    # Get the topic ID for this specific group\n    group_topic_id = GROUP_CONFIGS[chat_id]['topic_id']\n    \n    # Check if message is in the correct topic for this group\n    if group_topic_id and (not hasattr(msg, 'message_thread_id')\n                     or msg.message_thread_id != group_topic_id):\n        return\n\n    # Check if user has a last submission\n    if not user_last_submissions.get(chat_id, {}).get(user_id):\n        error_msg = await msg.reply_text(\n            \"‚ùå ·âÄ·ã®·â∞·àò·ãò·åà·â† ·àò·à®·åÉ ·ä†·àç·â∞·åà·äò·àù·ç¢\\n\\n·àò·åÄ·àò·à™·ã´ ·ä≠·çç·ã´ ·ã´·àµ·åà·â°·ç£ ·ä®·ãõ ·àõ·àµ·â∞·ä´·ä®·àç ·ã≠·âΩ·àã·àâ·ç¢\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n        return\n\n    last_sub = user_last_submissions[chat_id][user_id]\n    data = last_sub['data']\n\n    # Activate edit mode\n    user_edit_mode[chat_id][user_id] = True\n\n    # Start edit mode expiry timer\n    if chat_id in user_edit_mode_tasks and user_id in user_edit_mode_tasks[chat_id]:\n        user_edit_mode_tasks[chat_id][user_id].cancel()\n    user_edit_mode_tasks[chat_id][user_id] = asyncio.create_task(\n        expire_edit_mode(user_id, chat_id, context))\n\n    # Convert month and reason to Amharic\n    month_display = ETHIOPIAN_MONTHS_AMHARIC.get(data['month'], data['month'])\n    reason_display = PAYMENT_REASONS_AMHARIC.get(last_sub['sheet_name'], last_sub['sheet_name'].capitalize())\n\n    await msg.reply_text(f\"üìù ·ã®·â∞·àµ·â∞·ä´·ä®·àà·ãç ·àò·à®·åÉ:\\n\\n\"\n                         f\"üè† ·â§·âµ: {data['house_number'] or '‚Äî'}\\n\"\n                         f\"üë§ ·àµ·àù: {data['name'] or '‚Äî'}\\n\"\n                         f\"üí∞ ·àò·å†·äï: {data['amount']} ·â•·à≠\\n\"\n                         f\"üìÜ ·ãà·à≠: {month_display or '‚Äî'}\\n\"\n                         f\"üîñ TxID: {data['transaction_id'] or '‚Äî'}\\n\"\n                         f\"üìä ·àù·ä≠·äï·ã´·âµ: {reason_display}\\n\\n\"\n                         f\"‚ö†Ô∏è ·ä•·â£·ä≠·ãé ·àô·àâ·ãç·äï·äì ·ã®·â∞·àµ·â∞·ä´·ä®·àà·ãç·äï ·àò·à®·åÉ ·ä•·äï·ã∞·åà·äì ·ã≠·àã·ä©·ç¢\\n\"\n                         f\"·àÅ·àâ·äï·àù ·àò·à®·åÉ·ãé·âΩ (·â§·âµ·ç£ ·àò·å†·äï·ç£ ·ãà·à≠·ç£ ·ãà·ãò·â∞) ·ã´·ä´·âµ·â±·ç¢\\n\\n\"\n                         f\"·àô·àâ·ãç·äï ·àò·à®·åÉ ·àà·àò·àã·ä≠ {EDIT_MODE_DELAY} ·à∞·ä®·äï·ã∂·âΩ ·ä†·àâ·ãé·âµ·ç¢\")\n\n    logger.info(\n        f\"User {user_id} requested edit for last submission - EDIT MODE ACTIVATED\"\n    )\n\n\n# ========== BUTTON CLICK HANDLER ==========\nasync def handle_history_button(update: Update,\n                                context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle History button clicks - redirect to DM and show sender's house payment history\"\"\"\n    query = update.callback_query\n    await query.answer()\n\n    callback_data = query.data\n    if not callback_data.startswith(\"history_\"):\n        return\n\n    # Parse callback data: history_{user_id}_{house_number}\n    parts = callback_data.split(\"_\")\n    if len(parts) < 3:\n        return\n    \n    button_user_id = int(parts[1])\n    house_number = \"_\".join(parts[2:])  # Handle house numbers with underscores if any\n    \n    user_id = update.effective_user.id\n    chat_id = update.effective_chat.id\n\n    # SENDER-ONLY ACCESS: Only the original sender can view history\n    if user_id != button_user_id:\n        # Send error message to the unauthorized user's DM (not the group)\n        try:\n            await context.bot.send_message(\n                chat_id=user_id,\n                text=(\n                    f\"‚õî **Access Denied**\\n\"\n                    f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n                    f\"You can only view your own payment history.\\n\\n\"\n                    f\"·ã®·à´·àµ·ãé·äï ·ã®·ä≠·çç·ã´ ·â≥·à™·ä≠ ·â•·âª ·àõ·ã®·âµ ·ã≠·âΩ·àã·àâ·ç¢\\n\\n\"\n                    f\"If you need assistance, contact @sphinxlike\"\n                ),\n                parse_mode='Markdown'\n            )\n        except Exception as e:\n            logger.warning(f\"Could not send DM to user {user_id}: {e}\")\n            # If DM fails, prompt user to start bot first\n            await query.answer(\"Please start a chat with the bot first to receive messages\", show_alert=True)\n        return\n    \n    # Get the group_id to search in\n    if chat_id in GROUP_CONFIGS:\n        group_id = chat_id\n    else:\n        # Try to find the group from user's last submission\n        group_id = None\n        for gid in GROUP_CONFIGS.keys():\n            if user_last_submissions.get(gid, {}).get(button_user_id):\n                group_id = gid\n                break\n        \n        if not group_id:\n            await query.message.reply_text(\"‚ùå ·â°·ãµ·äï ·ä†·àç·â∞·åà·äò·àù\")\n            return\n\n    # Get bot username to create DM link\n    try:\n        bot_username = (await context.bot.get_me()).username\n    except:\n        bot_username = None\n    \n    # Send button in group to redirect to DM\n    if bot_username:\n        keyboard = [[\n            InlineKeyboardButton(\"üìã View History\", url=f\"https://t.me/{bot_username}\")\n        ]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.message.reply_text(\n            \"Your payment history is being sent to your DM.\\n\\nTap the button to open your chat:\",\n            reply_markup=reply_markup\n        )\n    \n    # Send history to user's DM\n    await show_house_payments_in_dm(context, user_id, house_number, group_id, query)\n\n\nasync def show_house_payments_amharic(query, house_number, group_id):\n    \"\"\"Show all payments for a specific house in Amharic\"\"\"\n    try:\n        logger.info(f\"üîç Showing payment history for house {house_number} in group {group_id}\")\n        sheets = setup_sheets(group_id)\n        \n        house_data = []\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = sheets.get(reason) if sheets else None\n                if not sheet:\n                    continue\n\n                values = sheet.get_all_values()\n                for i in range(2, len(values) - 1):  # Skip headers and TOTALS\n                    row = values[i]\n                    if len(row) > 1 and row[1].strip() == house_number.strip():\n                        house_name = row[2] if len(row) > 2 else ''\n                        \n                        for month_idx, month in enumerate(ETHIOPIAN_MONTHS):\n                            amount_col_idx = 3 + (month_idx * 2)\n                            ftno_col_idx = amount_col_idx + 1\n                            \n                            if len(row) > amount_col_idx:\n                                amount = row[amount_col_idx]\n                                txid = row[ftno_col_idx] if len(row) > ftno_col_idx else ''\n                                \n                                if amount and amount.strip():\n                                    try:\n                                        amount_value = float(amount)\n                                        house_data.append({\n                                            'name': house_name,\n                                            'amount': str(amount_value),\n                                            'month': month,\n                                            'txid': txid,\n                                            'type': reason\n                                        })\n                                    except ValueError:\n                                        pass\n            except Exception as e:\n                logger.warning(f\"Error reading {reason}: {e}\")\n\n        if not house_data:\n            await query.message.reply_text(\n                f\"üì≠ ·â§·âµ {house_number} ·àù·äï·àù ·ä≠·çç·ã´ ·ä†·àç·â∞·åà·äò·àù·ç¢\\n\"\n                f\"No payments found for house {house_number}.\")\n            return\n\n        # Get house name\n        house_name = house_data[0]['name'] if house_data else \"‚Äî\"\n        total = sum(float(p['amount']) for p in house_data if p['amount'])\n\n        message = f\"üè† **·â§·âµ {house_number}**\\n\"\n        message += f\"üë§ ·àµ·àù: {house_name}\\n\"\n        message += f\"üí∞ ·å†·âÖ·àã·àã: {total:,.0f} ·â•·à≠\\n\"\n        message += f\"üìä {len(house_data)} ·ä≠·çç·ã´·ãé·âΩ\\n\\n\"\n        message += \"**·ã®·ä≠·çç·ã´ ·â≥·à™·ä≠:**\\n\\n\"\n\n        for i, p in enumerate(house_data, 1):\n            reason_display = PAYMENT_REASONS_AMHARIC.get(p['type'], p['type'].capitalize())\n            month_display = ETHIOPIAN_MONTHS_AMHARIC.get(p['month'], p['month'])\n            message += (f\"{i}. {reason_display} - {month_display}\\n\"\n                        f\"   üí∞ {p['amount']} ·â•·à≠\\n\")\n            if p['txid']:\n                message += f\"   üîñ {p['txid']}\\n\"\n            message += \"\\n\"\n\n            if len(message) > 3500:\n                await query.message.reply_text(message, parse_mode='Markdown')\n                message = \"\"\n\n        if message:\n            await query.message.reply_text(message, parse_mode='Markdown')\n\n    except Exception as e:\n        logger.error(f\"Error in show_house_payments_amharic: {e}\", exc_info=True)\n        await query.message.reply_text(f\"‚ùå ·àµ·àÖ·â∞·âµ: {str(e)}\")\n\n\nasync def show_house_payments_in_dm(context, user_id, house_number, group_id, query):\n    \"\"\"Send house payment history to user's DM\"\"\"\n    try:\n        logger.info(f\"üîç Sending payment history to DM for house {house_number}, user {user_id}\")\n        sheets = setup_sheets(group_id)\n        \n        house_data = []\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = sheets.get(reason) if sheets else None\n                if not sheet:\n                    continue\n\n                values = sheet.get_all_values()\n                for i in range(2, len(values) - 1):  # Skip headers and TOTALS\n                    row = values[i]\n                    if len(row) > 1 and row[1].strip() == house_number.strip():\n                        house_name = row[2] if len(row) > 2 else ''\n                        \n                        for month_idx, month in enumerate(ETHIOPIAN_MONTHS):\n                            amount_col_idx = 3 + (month_idx * 2)\n                            ftno_col_idx = amount_col_idx + 1\n                            \n                            if len(row) > amount_col_idx:\n                                amount = row[amount_col_idx]\n                                txid = row[ftno_col_idx] if len(row) > ftno_col_idx else ''\n                                \n                                if amount and amount.strip():\n                                    try:\n                                        amount_value = float(amount)\n                                        house_data.append({\n                                            'name': house_name,\n                                            'amount': str(amount_value),\n                                            'month': month,\n                                            'txid': txid,\n                                            'type': reason\n                                        })\n                                    except ValueError:\n                                        pass\n            except Exception as e:\n                logger.warning(f\"Error reading {reason}: {e}\")\n\n        if not house_data:\n            await context.bot.send_message(\n                chat_id=user_id,\n                text=(\n                    f\"üì≠ ·â§·âµ {house_number} ·àù·äï·àù ·ä≠·çç·ã´ ·ä†·àç·â∞·åà·äò·àù·ç¢\\n\"\n                    f\"No payments found for house {house_number}.\"\n                ),\n                parse_mode='Markdown'\n            )\n            # Notify in group that history was sent to DM\n            await query.answer(\"History sent to your DM\", show_alert=True)\n            return\n\n        # Get house name\n        house_name = house_data[0]['name'] if house_data else \"‚Äî\"\n        total = sum(float(p['amount']) for p in house_data if p['amount'])\n\n        message = f\"üìã **·ã®·ä≠·çç·ã´ ·â≥·à™·ä≠ - Payment History**\\n\"\n        message += f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n        message += f\"üè† **·â§·âµ {house_number}**\\n\"\n        message += f\"üë§ ·àµ·àù: {house_name}\\n\"\n        message += f\"üí∞ ·å†·âÖ·àã·àã: {total:,.0f} ·â•·à≠\\n\"\n        message += f\"üìä {len(house_data)} ·ä≠·çç·ã´·ãé·âΩ\\n\\n\"\n        message += \"**·ã®·ä≠·çç·ã´ ·ãù·à≠·ãù·à≠:**\\n\\n\"\n\n        for i, p in enumerate(house_data, 1):\n            reason_display = PAYMENT_REASONS_AMHARIC.get(p['type'], p['type'].capitalize())\n            month_display = ETHIOPIAN_MONTHS_AMHARIC.get(p['month'], p['month'])\n            message += (f\"{i}. {reason_display} - {month_display}\\n\"\n                        f\"   üí∞ {p['amount']} ·â•·à≠\\n\")\n            if p['txid']:\n                message += f\"   üîñ {p['txid']}\\n\"\n            message += \"\\n\"\n\n            # Split long messages\n            if len(message) > 3500:\n                await context.bot.send_message(\n                    chat_id=user_id,\n                    text=message,\n                    parse_mode='Markdown'\n                )\n                message = \"\"\n\n        if message:\n            await context.bot.send_message(\n                chat_id=user_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n        \n        # Notify in group that history was sent to DM\n        await query.answer(\"History sent to your DM ‚úì\", show_alert=True)\n        logger.info(f\"‚úì Payment history sent to DM for user {user_id}\")\n\n    except Exception as e:\n        logger.error(f\"Error in show_house_payments_in_dm: {e}\", exc_info=True)\n        try:\n            await context.bot.send_message(\n                chat_id=user_id,\n                text=f\"‚ùå Error loading history: {str(e)}\\n\\nContact @sphinxlike for help.\",\n                parse_mode='Markdown'\n            )\n        except:\n            await query.answer(\"Could not send DM. Please start a chat with the bot first.\", show_alert=True)\n\n\nasync def handle_edit_button(update: Update,\n                             context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle Edit button clicks\"\"\"\n    query = update.callback_query\n    await query.answer()  # Acknowledge the button click\n\n    user_id = update.effective_user.id\n    chat_id = update.effective_chat.id\n\n    # Verify this is the correct user (security check)\n    callback_data = query.data\n    if not callback_data.startswith(\"edit_\"):\n        return\n\n    button_user_id = int(callback_data.split(\"_\")[1])\n    if user_id != button_user_id:\n        error_msg = await safe_reply_text(query.message, \"‚ùå ·àõ·àµ·â∞·ä´·ä®·àç ·ã®·àö·âΩ·àâ·âµ ·ã®·à´·àµ·ãé·äï ·àò·à®·åÉ ·â•·âª ·äê·ãç!\")\n        if error_msg:\n            asyncio.create_task(delete_message_after(error_msg, 600))\n        logger.warning(\n            f\"User {user_id} tried to edit submission from user {button_user_id}\"\n        )\n        return\n\n    # Check if user has a last submission\n    if not user_last_submissions.get(chat_id, {}).get(user_id):\n        error_msg = await safe_reply_text(query.message, \"‚ùå ·ä®·ãö ·â†·çä·âµ ·ã®·â∞·àò·ãò·åà·â† ·àò·à®·åÉ ·ä†·àç·â∞·åà·äò·àù·ç¢\")\n        if error_msg:\n            asyncio.create_task(delete_message_after(error_msg, 600))\n        return\n\n    last_sub = user_last_submissions[chat_id][user_id]\n    data = last_sub['data']\n\n    # Activate edit mode\n    user_edit_mode[chat_id][user_id] = True\n\n    # Start edit mode expiry timer\n    if chat_id in user_edit_mode_tasks and user_id in user_edit_mode_tasks[chat_id]:\n        user_edit_mode_tasks[chat_id][user_id].cancel()\n    user_edit_mode_tasks[chat_id][user_id] = asyncio.create_task(\n        expire_edit_mode(user_id, chat_id, context))\n\n    # Convert month and reason to Amharic\n    month_display = ETHIOPIAN_MONTHS_AMHARIC.get(data['month'], data['month'])\n    reason_display = PAYMENT_REASONS_AMHARIC.get(last_sub['sheet_name'], last_sub['sheet_name'].capitalize())\n\n    await query.message.reply_text(\n        f\"üìù ·ã®·ä•·à≠·àµ·ãé ·ã®·àò·å®·à®·àª ·àò·à®·åÉ:\\n\\n\"\n        f\"üè† ·â§·âµ: {data['house_number'] or '‚Äî'}\\n\"\n        f\"üë§ ·àµ·àù: {data['name'] or '‚Äî'}\\n\"\n        f\"üí∞ ·àò·å†·äï: {data['amount']} ·â•·à≠\\n\"\n        f\"üìÜ ·ãà·à≠: {month_display or '‚Äî'}\\n\"\n        f\"üîñ TxID: {data['transaction_id'] or '‚Äî'}\\n\"\n        f\"üìä ·àù·ä≠·äï·ã´·âµ: {reason_display}\\n\\n\"\n        f\"‚ö†Ô∏è ·ä•·â£·ä≠·ãé ·àô·àâ·ãç·äï·äì ·ã®·â∞·àµ·â∞·ä´·ä®·àà·ãç·äï ·àò·à®·åÉ ·ä•·äï·ã∞·åà·äì ·ã≠·àã·ä©·ç¢\\n\"\n        f\"·àÅ·àâ·äï·àù ·àò·à®·åÉ·ãé·âΩ (·â§·âµ·ç£ ·àò·å†·äï·ç£ ·ãà·à≠·ç£ ·ãà·ãò·â∞) ·ã´·ä´·âµ·â±·ç¢\\n\\n\"\n        f\"·àô·àâ·ãç·äï ·àò·à®·åÉ ·àà·àò·àã·ä≠ {EDIT_MODE_DELAY} ·à∞·ä®·äï·ã∂·âΩ ·ä†·àâ·ãé·âµ·ç¢\")\n\n    logger.info(f\"User {user_id} clicked Edit button - EDIT MODE ACTIVATED\")\n\n\n# ========== ADMIN FUNCTIONS ==========\ndef is_admin(user_id: int, chat_id: int) -> bool:\n    \"\"\"Check if user is an admin for the specified group or any group (if private chat)\"\"\"\n    # If this is a group chat, check if user is admin for that specific group\n    if chat_id in GROUP_CONFIGS:\n        group_config = GROUP_CONFIGS[chat_id]\n        admin_ids = group_config.get('admin_user_ids', [])\n        return user_id in admin_ids\n    \n    # If private chat (chat_id not in GROUP_CONFIGS), check if user is admin in ANY group\n    # This allows admins to use the admin panel in private messages\n    for group_chat_id, group_config in GROUP_CONFIGS.items():\n        admin_ids = group_config.get('admin_user_ids', [])\n        if user_id in admin_ids:\n            return True\n    \n    logger.warning(f\"‚ö†Ô∏è User {user_id} is not an admin in any configured group\")\n    return False\n\n\ndef get_admin_groups(user_id: int) -> dict:\n    \"\"\"Get all groups where user is an admin\"\"\"\n    admin_groups = {}\n    for chat_id, group_config in GROUP_CONFIGS.items():\n        admin_ids = group_config.get('admin_user_ids', [])\n        if user_id in admin_ids:\n            admin_groups[chat_id] = group_config\n    return admin_groups\n\n\ndef get_admin_menu_keyboard():\n    \"\"\"Get the professional admin menu with horizontal layout\"\"\"\n    keyboard = [\n        [\n            InlineKeyboardButton(\"üìä Dashboard\", callback_data=\"admin_dashboard\"),\n            InlineKeyboardButton(\"üìÖ Monthly\", callback_data=\"admin_monthly_totals\")\n        ],\n        [\n            InlineKeyboardButton(\"üîç Search\", callback_data=\"admin_search\"),\n            InlineKeyboardButton(\"üìã Houses\", callback_data=\"admin_houses\")\n        ],\n        [\n            InlineKeyboardButton(\"üóÇÔ∏è Recent\", callback_data=\"admin_recent\"),\n            InlineKeyboardButton(\"üì• Excel\", callback_data=\"admin_download_excel\")\n        ],\n        [\n            InlineKeyboardButton(\"üîô Back to Start\", callback_data=\"back_to_start\")\n        ]\n    ]\n    return InlineKeyboardMarkup(keyboard)\n\n\ndef get_admin_panel_text(group_name: str) -> str:\n    \"\"\"Get professional admin panel header text\"\"\"\n    return (\n        f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\"\n        f\"üë®‚Äçüíº **Admin Panel**\\n\"\n        f\"üìç {group_name}\\n\"\n        f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n        f\"Select an option below:\"\n    )\n\n\nasync def handle_start_command(update: Update,\n                               context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle /start command - works in DMs for bot intro and admin access\"\"\"\n    user_id = update.effective_user.id\n    chat_id = update.effective_chat.id\n    first_name = update.effective_user.first_name or \"\"\n    \n    # Check if this is a private chat (DM)\n    if update.effective_chat.type == 'private':\n        # Check if user is admin in any group\n        admin_groups = get_admin_groups(user_id)\n        \n        # Always show role selection popup for professional experience\n        keyboard = [\n            [\n                InlineKeyboardButton(\"üë®‚Äçüíº Admin Access\", callback_data=\"role_admin\"),\n                InlineKeyboardButton(\"üë§ User Access\", callback_data=\"role_user\")\n            ]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        # Professional welcome message\n        welcome_msg = (\n            f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\"\n            f\"üè¶ **Payment Receipt Bot**\\n\"\n            f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n            f\"üëã ·ä•·äï·ä≥·äï ·ã∞·àÖ·äì ·àò·å°, {first_name}!\\n\"\n            f\"     Welcome, {first_name}!\\n\\n\"\n            f\"üìå **Please select your role:**\\n\\n\"\n            f\"‚Ä¢ **Admin Access** - Manage payments,\\n\"\n            f\"   view reports & download data\\n\\n\"\n            f\"‚Ä¢ **User Access** - View bot info\\n\"\n            f\"   & learn how to submit receipts\"\n        )\n        \n        await update.message.reply_text(\n            welcome_msg,\n            reply_markup=reply_markup,\n            parse_mode='Markdown')\n    else:\n        # In group chat, just confirm bot is working\n        await update.message.reply_text(\n            f\"üëã Bot is running!\\n\"\n            f\"Send payment receipts in this topic.\")\n\n\nasync def handle_myid_command(update: Update,\n                              context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Show user their Telegram ID\"\"\"\n    user_id = update.effective_user.id\n    username = update.effective_user.username or \"No username\"\n    first_name = update.effective_user.first_name or \"\"\n\n    await update.message.reply_text(\n        f\"üì± Your Telegram Info:\\n\\n\"\n        f\"üÜî User ID: `{user_id}`\\n\"\n        f\"üë§ Name: {first_name}\\n\"\n        f\"@{username}\\n\\n\"\n        f\"‚ÑπÔ∏è Give your User ID to the admin to get admin access.\",\n        parse_mode='Markdown')\n\n\nasync def handle_admin_command(update: Update,\n                               context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Show admin panel with options\"\"\"\n    user_id = update.effective_user.id\n    chat_id = update.effective_chat.id\n\n    if not is_admin(user_id, chat_id):\n        error_msg = await update.message.reply_text(\"‚ùå You don't have admin access.\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n        return\n\n    # Get groups where user is admin\n    admin_groups = get_admin_groups(user_id)\n    \n    # If in private chat and admin manages multiple groups, show group selector\n    if chat_id not in GROUP_CONFIGS and len(admin_groups) > 1:\n        keyboard = []\n        for group_chat_id, group_config in admin_groups.items():\n            group_name = group_config.get('name', f'Group {group_chat_id}')\n            keyboard.append([\n                InlineKeyboardButton(\n                    f\"üìä {group_name}\",\n                    callback_data=f\"select_group_{group_chat_id}\"\n                )\n            ])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await update.message.reply_text(\n            \"üë®‚Äçüíº **Admin Panel**\\n\\n\"\n            \"You are admin for multiple groups. Please select a group:\",\n            reply_markup=reply_markup,\n            parse_mode='Markdown')\n        return\n    \n    # If in private chat with only one group, use that group\n    if chat_id not in GROUP_CONFIGS:\n        chat_id = list(admin_groups.keys())[0]\n        context.user_data['admin_group_id'] = chat_id\n    else:\n        # If in group chat, use that group\n        context.user_data['admin_group_id'] = chat_id\n\n    group_name = GROUP_CONFIGS[chat_id].get('name', 'Group')\n    await update.message.reply_text(\n        get_admin_panel_text(group_name),\n        reply_markup=get_admin_menu_keyboard(),\n        parse_mode='Markdown')\n\n\nasync def handle_admin_callbacks(update: Update,\n                                 context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle admin panel button clicks\"\"\"\n    query = update.callback_query\n    await query.answer()\n\n    user_id = update.effective_user.id\n    chat_id = update.effective_chat.id\n    first_name = update.effective_user.first_name or \"\"\n    data = query.data\n    \n    # Handle role selection from /start (no admin check needed for initial selection)\n    if data == \"role_user\":\n        # Show user info panel\n        user_msg = (\n            f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\"\n            f\"üë§ **User Information**\\n\"\n            f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n            f\"üëã ·à∞·àã·àù {first_name}!\\n\\n\"\n            f\"·ã≠·àÖ ·â¶·âµ ·ã®·ä≠·çç·ã´ ·ã∞·à®·à∞·äû·âΩ·äï ·àà·àõ·àµ·â∞·äì·åà·ãµ ·äê·ãç·ç¢\\n\"\n            f\"This bot processes payment receipts.\\n\\n\"\n            f\"üìå **How to use:**\\n\"\n            f\"‚Ä¢ Send payment receipts in the group chat\\n\"\n            f\"‚Ä¢ Include house number in your message\\n\"\n            f\"‚Ä¢ Bot will automatically extract & save data\\n\\n\"\n            f\"üÜî Your ID: `{user_id}`\\n\"\n            f\"‚ÑπÔ∏è Share this ID with admin for access.\"\n        )\n        keyboard = [[InlineKeyboardButton(\"üîô Back to Start\", callback_data=\"back_to_start\")]]\n        await query.edit_message_text(\n            user_msg,\n            reply_markup=InlineKeyboardMarkup(keyboard),\n            parse_mode='Markdown')\n        return\n    \n    if data == \"role_admin\":\n        # Check if user is actually an admin\n        admin_groups = get_admin_groups(user_id)\n        if not admin_groups:\n            # Not an admin - show access denied\n            deny_msg = (\n                f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\"\n                f\"‚õî **Access Denied**\\n\"\n                f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n                f\"You don't have admin privileges.\\n\\n\"\n                f\"üÜî Your ID: `{user_id}`\\n\\n\"\n                f\"Contact @sphinxlike to get access.\"\n            )\n            keyboard = [[InlineKeyboardButton(\"üîô Back to Start\", callback_data=\"back_to_start\")]]\n            await query.edit_message_text(\n                deny_msg,\n                reply_markup=InlineKeyboardMarkup(keyboard),\n                parse_mode='Markdown')\n            return\n        \n        # User is admin - show group selection or admin panel\n        if len(admin_groups) > 1:\n            keyboard = []\n            for group_chat_id, group_config in admin_groups.items():\n                group_name = group_config.get('name', f'Group {group_chat_id}')\n                keyboard.append([\n                    InlineKeyboardButton(\n                        f\"üìä {group_name}\",\n                        callback_data=f\"select_group_{group_chat_id}\"\n                    )\n                ])\n            keyboard.append([InlineKeyboardButton(\"üîô Back to Start\", callback_data=\"back_to_start\")])\n            await query.edit_message_text(\n                f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\"\n                f\"üë®‚Äçüíº **Select Group**\\n\"\n                f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n                f\"You manage {len(admin_groups)} group(s).\\n\"\n                f\"Please select one:\",\n                reply_markup=InlineKeyboardMarkup(keyboard),\n                parse_mode='Markdown')\n        else:\n            # Only one group\n            admin_group_id = list(admin_groups.keys())[0]\n            context.user_data['admin_group_id'] = admin_group_id\n            group_name = GROUP_CONFIGS[admin_group_id].get('name', 'Group')\n            await query.edit_message_text(\n                get_admin_panel_text(group_name),\n                reply_markup=get_admin_menu_keyboard(),\n                parse_mode='Markdown')\n        return\n    \n    if data == \"back_to_start\":\n        # Go back to start menu\n        keyboard = [\n            [\n                InlineKeyboardButton(\"üë®‚Äçüíº Admin Access\", callback_data=\"role_admin\"),\n                InlineKeyboardButton(\"üë§ User Access\", callback_data=\"role_user\")\n            ]\n        ]\n        welcome_msg = (\n            f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\"\n            f\"üè¶ **Payment Receipt Bot**\\n\"\n            f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n            f\"üëã ·ä•·äï·ä≥·äï ·ã∞·àÖ·äì ·àò·å°, {first_name}!\\n\"\n            f\"     Welcome, {first_name}!\\n\\n\"\n            f\"üìå **Please select your role:**\\n\\n\"\n            f\"‚Ä¢ **Admin Access** - Manage payments,\\n\"\n            f\"   view reports & download data\\n\\n\"\n            f\"‚Ä¢ **User Access** - View bot info\\n\"\n            f\"   & learn how to submit receipts\"\n        )\n        await query.edit_message_text(\n            welcome_msg,\n            reply_markup=InlineKeyboardMarkup(keyboard),\n            parse_mode='Markdown')\n        return\n\n    # From here, admin access is required\n    if not is_admin(user_id, chat_id):\n        error_msg = await query.message.reply_text(\"‚ùå You don't have admin access.\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n        return\n    \n    # Handle group selection\n    if data.startswith(\"select_group_\"):\n        selected_group_id = int(data.replace(\"select_group_\", \"\"))\n        context.user_data['admin_group_id'] = selected_group_id\n        group_name = GROUP_CONFIGS[selected_group_id].get('name', 'Group')\n        \n        await query.edit_message_text(\n            get_admin_panel_text(group_name),\n            reply_markup=get_admin_menu_keyboard(),\n            parse_mode='Markdown')\n        return\n\n    # Get the group_id to use for admin operations\n    # Use stored group_id if in private chat, otherwise use current chat_id\n    admin_group_id = context.user_data.get('admin_group_id', chat_id)\n    \n    # Store it in context for the admin functions to use\n    context.user_data['admin_group_id'] = admin_group_id\n\n    if data == \"admin_start\":\n        # Handle admin_start from /start command in DM\n        admin_groups = get_admin_groups(user_id)\n        if len(admin_groups) > 1:\n            keyboard = []\n            for group_chat_id, group_config in admin_groups.items():\n                group_name = group_config.get('name', f'Group {group_chat_id}')\n                keyboard.append([\n                    InlineKeyboardButton(\n                        f\"üìä {group_name}\",\n                        callback_data=f\"select_group_{group_chat_id}\"\n                    )\n                ])\n            keyboard.append([InlineKeyboardButton(\"üîô Back to Start\", callback_data=\"back_to_start\")])\n            await query.edit_message_text(\n                f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\"\n                f\"üë®‚Äçüíº **Select Group**\\n\"\n                f\"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\n\\n\"\n                f\"You manage {len(admin_groups)} group(s).\\n\"\n                f\"Please select one:\",\n                reply_markup=InlineKeyboardMarkup(keyboard),\n                parse_mode='Markdown')\n        else:\n            # Only one group\n            admin_group_id = list(admin_groups.keys())[0]\n            context.user_data['admin_group_id'] = admin_group_id\n            group_name = GROUP_CONFIGS[admin_group_id].get('name', 'Group')\n            await query.edit_message_text(\n                get_admin_panel_text(group_name),\n                reply_markup=get_admin_menu_keyboard(),\n                parse_mode='Markdown')\n    elif data == \"admin_dashboard\":\n        await show_dashboard(query, admin_group_id)\n    elif data == \"admin_monthly_totals\":\n        await show_monthly_totals(query, admin_group_id)\n    elif data == \"admin_recent\":\n        await show_recent_payments(query, admin_group_id)\n    elif data == \"admin_search\":\n        await prompt_house_search(query, admin_group_id)\n    elif data == \"admin_stats\":\n        await show_payment_stats(query, admin_group_id)\n    elif data == \"admin_houses\":\n        await show_all_houses(query, admin_group_id)\n    elif data == \"admin_download_excel\":\n        await download_excel(query, context, admin_group_id)\n    elif data.startswith(\"house_\"):\n        house_number = data.split(\"_\")[1]\n        await show_house_payments(query, house_number, admin_group_id)\n\n\nasync def download_excel(query, context, group_id):\n    \"\"\"Download the payment data as Excel file and send to user\"\"\"\n    try:\n        import io\n        \n        await query.message.reply_text(\"‚è≥ Generating Excel file... Please wait.\")\n        \n        group_config = GROUP_CONFIGS.get(group_id)\n        if not group_config:\n            await query.message.reply_text(\"‚ùå Group configuration not found.\")\n            return\n            \n        spreadsheet_id = group_config.get('spreadsheet_id')\n        if not spreadsheet_id:\n            await query.message.reply_text(\"‚ùå Spreadsheet not configured for this group.\")\n            return\n        \n        # Get the spreadsheet export URL\n        export_url = f\"https://docs.google.com/spreadsheets/d/{spreadsheet_id}/export?format=xlsx\"\n        \n        # We need to use the authenticated client to download\n        # Get the credentials from our existing setup\n        creds = service_account.Credentials.from_service_account_file(\n            CREDENTIALS_FILE,\n            scopes=['https://www.googleapis.com/auth/spreadsheets',\n                    'https://www.googleapis.com/auth/drive.readonly']\n        )\n        \n        # Use requests with the authorized session\n        from google.auth.transport.requests import AuthorizedSession\n        authed_session = AuthorizedSession(creds)\n        \n        response = authed_session.get(export_url)\n        \n        if response.status_code == 200:\n            # Create file-like object from content\n            excel_file = io.BytesIO(response.content)\n            excel_file.name = f\"payments_{group_config.get('name', 'group')}_{datetime.now().strftime('%Y%m%d')}.xlsx\"\n            \n            # Send the file to user\n            group_name = group_config.get('name', 'Group')\n            await context.bot.send_document(\n                chat_id=query.message.chat_id,\n                document=excel_file,\n                filename=excel_file.name,\n                caption=f\"üìä Payment data for {group_name}\\n\"\n                        f\"üìÖ Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}\"\n            )\n            logger.info(f\"‚úÖ Excel file sent to user {query.from_user.id}\")\n        else:\n            logger.error(f\"Failed to download Excel: {response.status_code} - {response.text[:200]}\")\n            await query.message.reply_text(f\"‚ùå Failed to download Excel file. Status: {response.status_code}\")\n            \n    except Exception as e:\n        logger.error(f\"Error in download_excel: {e}\", exc_info=True)\n        await query.message.reply_text(f\"‚ùå Error generating Excel: {str(e)}\")\n\n\nasync def show_dashboard(query, group_id):\n    \"\"\"Show comprehensive dashboard with overall statistics and monthly overview\"\"\"\n    try:\n        sheets = setup_sheets(group_id)\n        \n        stats = {}\n        total_all = 0\n        unique_people_all = set()\n        monthly_totals = {month: 0 for month in ETHIOPIAN_MONTHS}\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = sheets.get(reason) if sheets else None\n                if not sheet:\n                    continue\n\n                all_values = sheet.get_all_values()\n                \n                # Find TOTAL row (should have \"TOTAL\" in column B)\n                totals_row = None\n                for row in all_values:\n                    if len(row) > 1 and row[1] == 'TOTAL':\n                        totals_row = row\n                        break\n                \n                if totals_row:\n                    # Calculate total for this reason from all monthly totals\n                    reason_total = 0\n                    for month_idx in range(len(ETHIOPIAN_MONTHS)):\n                        amount_col_idx = 3 + (month_idx * 2)\n                        if amount_col_idx < len(totals_row):\n                            try:\n                                value_str = str(totals_row[amount_col_idx]).strip()\n                                # Skip if empty or is a formula string\n                                if value_str and not value_str.startswith('='):\n                                    # Remove commas from formatted numbers\n                                    value_str = value_str.replace(',', '')\n                                    month_val = float(value_str)\n                                    monthly_totals[ETHIOPIAN_MONTHS[month_idx]] += month_val\n                                    reason_total += month_val\n                            except ValueError as e:\n                                logger.warning(f\"Could not parse total value '{totals_row[amount_col_idx]}' for {reason} month {month_idx}\")\n                                pass\n                    \n                    # Count unique house numbers that actually paid (have at least one amount)\n                    unique_houses = set()\n                    for row in all_values[2:]:  # Skip headers (rows 1-2)\n                        if row and len(row) > 1 and row[1] and row[1] != 'TOTAL':\n                            house_number = row[1].strip()\n                            if house_number:\n                                # Check if this house has any payment in any month\n                                has_payment = False\n                                for month_idx in range(len(ETHIOPIAN_MONTHS)):\n                                    amount_col_idx = 3 + (month_idx * 2)  # Amount column for each month\n                                    if amount_col_idx < len(row):\n                                        amount = row[amount_col_idx]\n                                        if amount and str(amount).strip():  # Has a value\n                                            try:\n                                                if float(amount) > 0:\n                                                    has_payment = True\n                                                    break\n                                            except:\n                                                pass\n                                \n                                if has_payment:\n                                    unique_houses.add(house_number)\n                                    unique_people_all.add(house_number)\n                    \n                    stats[reason] = {'total': reason_total, 'people': len(unique_houses)}\n                    total_all += reason_total\n\n            except Exception as e:\n                logger.error(f\"Error reading stats for {reason}: {e}\")\n\n        message = \"üìä **Payment Dashboard**\\n\\n\"\n        message += f\"üí∞ **Grand Total: {total_all:,.2f} birr**\\n\"\n        message += f\"üë• **Total People Paid: {len(unique_people_all)}**\\n\\n\"\n        \n        message += \"**By Payment Type:**\\n\"\n        for reason, data in stats.items():\n            if data['total'] > 0:\n                reason_display = PAYMENT_REASONS_AMHARIC.get(reason, reason.capitalize())\n                message += f\"  ‚Ä¢ {reason_display}: {data['total']:,.2f} birr ({data['people']} people)\\n\"\n        \n        message += \"\\n**Top 3 Months:**\\n\"\n        sorted_months = sorted(monthly_totals.items(), key=lambda x: x[1], reverse=True)[:3]\n        for month, total in sorted_months:\n            if total > 0:\n                month_display = ETHIOPIAN_MONTHS_AMHARIC.get(month, month)\n                message += f\"  {month_display}: {total:,.2f} birr\\n\"\n\n        await query.message.reply_text(message, parse_mode='Markdown')\n\n    except Exception as e:\n        logger.error(f\"Error in show_dashboard: {e}\")\n        error_msg = await query.message.reply_text(f\"‚ùå Error: {e}\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n\n\nasync def show_monthly_totals(query, group_id):\n    \"\"\"Show totals for each month across all payment types\"\"\"\n    try:\n        sheets = setup_sheets(group_id)\n        \n        monthly_totals = {month: 0 for month in ETHIOPIAN_MONTHS}\n        monthly_breakdown = {month: {} for month in ETHIOPIAN_MONTHS}\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = sheets.get(reason) if sheets else None\n                if not sheet:\n                    continue\n\n                # Use get_all_values() which returns formatted/calculated values\n                all_values = sheet.get_all_values()\n                \n                # Find TOTAL row\n                totals_row = None\n                totals_row_idx = None\n                for idx, row in enumerate(all_values):\n                    if len(row) > 1 and row[1] == 'TOTAL':\n                        totals_row = row\n                        totals_row_idx = idx\n                        break\n                \n                if totals_row:\n                    for month_idx in range(len(ETHIOPIAN_MONTHS)):\n                        amount_col_idx = 3 + (month_idx * 2)\n                        if amount_col_idx < len(totals_row):\n                            try:\n                                value_str = str(totals_row[amount_col_idx]).strip()\n                                # Skip if empty or is a formula string\n                                if value_str and not value_str.startswith('='):\n                                    # Remove commas from formatted numbers\n                                    value_str = value_str.replace(',', '')\n                                    month_val = float(value_str)\n                                    month_name = ETHIOPIAN_MONTHS[month_idx]\n                                    monthly_totals[month_name] += month_val\n                                    \n                                    if month_val > 0:\n                                        if month_name not in monthly_breakdown:\n                                            monthly_breakdown[month_name] = {}\n                                        monthly_breakdown[month_name][reason] = month_val\n                            except ValueError as e:\n                                logger.warning(f\"Could not parse value '{totals_row[amount_col_idx]}' for {reason} month {month_idx}: {e}\")\n                                pass\n\n            except Exception as e:\n                logger.error(f\"Error reading monthly totals for {reason}: {e}\")\n\n        message = \"üìÖ **Monthly Totals Report**\\n\\n\"\n        \n        for month in ETHIOPIAN_MONTHS:\n            total = monthly_totals[month]\n            if total > 0:\n                month_display = ETHIOPIAN_MONTHS_AMHARIC.get(month, month)\n                message += f\"**{month_display}:** {total:,.2f} birr\\n\"\n                \n                # Show breakdown by payment type\n                if month in monthly_breakdown:\n                    for reason, amount in monthly_breakdown[month].items():\n                        reason_display = PAYMENT_REASONS_AMHARIC.get(reason, reason.capitalize())\n                        message += f\"  ‚Ä¢ {reason_display}: {amount:,.2f} birr\\n\"\n                message += \"\\n\"\n\n        if all(v == 0 for v in monthly_totals.values()):\n            message += \"No payments recorded yet.\"\n\n        await query.message.reply_text(message, parse_mode='Markdown')\n\n    except Exception as e:\n        logger.error(f\"Error in show_monthly_totals: {e}\")\n        error_msg = await query.message.reply_text(f\"‚ùå Error: {e}\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n\n\nasync def show_recent_payments(query, group_id):\n    \"\"\"Show last 10 payments across all sheets\"\"\"\n    try:\n        sheets = setup_sheets(group_id)\n        \n        all_payments = []\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = sheets.get(reason) if sheets else None\n                if not sheet:\n                    continue\n\n                values = sheet.get_all_values()\n                # Skip 2 header rows, data starts at row 3 (index 2)\n                # Last row is TOTALS, skip it\n                for i in range(2, len(values) - 1):\n                    row = values[i]\n                    if len(row) > 2:\n                        house_number = row[1] if len(row) > 1 else ''  # Column B\n                        house_name = row[2] if len(row) > 2 else ''    # Column C\n                        \n                        # Check each month's columns for payments\n                        for month_idx, month in enumerate(ETHIOPIAN_MONTHS):\n                            amount_col_idx = 3 + (month_idx * 2)  # Amount column\n                            ftno_col_idx = amount_col_idx + 1     # FT No column\n                            \n                            if amount_col_idx < len(row):\n                                amount = row[amount_col_idx]\n                                if amount and str(amount).strip():\n                                    try:\n                                        float(amount)  # Validate it's a number\n                                        txid = row[ftno_col_idx] if ftno_col_idx < len(row) else ''\n                                        all_payments.append({\n                                            'house': house_number,\n                                            'name': house_name,\n                                            'amount': amount,\n                                            'month': month,\n                                            'txid': txid,\n                                            'type': reason\n                                        })\n                                    except:\n                                        pass\n            except Exception as e:\n                logger.error(f\"Error reading {reason}: {e}\")\n\n        # Just take last 10 (can't sort by time since we don't have timestamps in this format)\n        recent = all_payments[-10:] if len(all_payments) > 10 else all_payments\n\n        if not recent:\n            await query.message.reply_text(\"üì≠ No payments found.\")\n            return\n\n        message = \"üìä **Last 10 Payments:**\\n\\n\"\n        for i, p in enumerate(recent, 1):\n            reason_display = PAYMENT_REASONS_AMHARIC.get(p['type'], p['type'].capitalize())\n            month_display = ETHIOPIAN_MONTHS_AMHARIC.get(p['month'], p['month'])\n            message += (f\"{i}. üè† {p['house']} | {p['name']}\\n\"\n                        f\"   üí∞ {p['amount']} birr | {reason_display}\\n\"\n                        f\"   üìÜ {month_display}\\n\\n\")\n\n        await query.message.reply_text(message, parse_mode='Markdown')\n\n    except Exception as e:\n        logger.error(f\"Error in show_recent_payments: {e}\")\n        error_msg = await query.message.reply_text(f\"‚ùå Error: {e}\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n\n\nasync def prompt_house_search(query, group_id):\n    \"\"\"Prompt for house number to search\"\"\"\n    user_id = query.from_user.id\n    # Store both the flag and the group_id so we know which group to search\n    admin_search_mode[group_id][user_id] = group_id\n    await query.message.reply_text(\n        \"üîç **Search by House Number**\\n\\n\"\n        \"Send the house number (3 or 4 digits) to see all payments for that house.\\n\\n\"\n        \"Example: `507` or `901`\",\n        parse_mode='Markdown')\n\n\nasync def show_payment_stats(query, group_id):\n    \"\"\"Show overall payment statistics\"\"\"\n    try:\n        sheets = setup_sheets(group_id)\n        \n        stats = {}\n        total_all = 0\n        count_all = 0\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = sheets.get(reason) if sheets else None\n                if not sheet:\n                    continue\n\n                values = sheet.get_all_values()\n                total_row = len(values)\n\n                # Get total from last row\n                if total_row > 1:\n                    total_value = sheet.acell(\n                        f'C{total_row}',\n                        value_render_option='UNFORMATTED_VALUE').value\n                    try:\n                        total = float(total_value) if total_value else 0\n                    except:\n                        total = 0\n\n                    count = total_row - 2  # Exclude header and total row\n                    stats[reason] = {'total': total, 'count': count}\n                    total_all += total\n                    count_all += count\n\n            except Exception as e:\n                logger.error(f\"Error reading stats for {reason}: {e}\")\n\n        message = \"üìà **Payment Statistics**\\n\\n\"\n\n        for reason, data in stats.items():\n            if data['count'] > 0:\n                message += f\"**{reason.capitalize()}:**\\n\"\n                message += f\"  üí∞ Total: {data['total']:,.2f} birr\\n\"\n                message += f\"  üìä Count: {data['count']} payments\\n\\n\"\n\n        message += f\"\\n**Overall:**\\n\"\n        message += f\"üí∞ **Total: {total_all:,.2f} birr**\\n\"\n        message += f\"üìä **Count: {count_all} payments**\"\n\n        await query.message.reply_text(message, parse_mode='Markdown')\n\n    except Exception as e:\n        logger.error(f\"Error in show_payment_stats: {e}\")\n        error_msg = await query.message.reply_text(f\"‚ùå Error: {e}\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n\n\nasync def show_all_houses(query, group_id):\n    \"\"\"Show list of houses with payment counts\"\"\"\n    try:\n        sheets = setup_sheets(group_id)\n        \n        house_payments = defaultdict(int)\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = sheets.get(reason) if sheets else None\n                if not sheet:\n                    continue\n\n                values = sheet.get_all_values()\n                # Skip 2 header rows, data starts at row 3 (index 2)\n                # Last row is TOTALS, skip it\n                for i in range(2, len(values) - 1):\n                    row = values[i]\n                    if len(row) > 1:\n                        house_number = row[1]  # Column B (H.No)\n                        if house_number and house_number.strip():\n                            # Count how many months this house has payments for\n                            payment_count = 0\n                            for month_idx in range(len(ETHIOPIAN_MONTHS)):\n                                amount_col_idx = 3 + (month_idx * 2)  # Amount column\n                                if amount_col_idx < len(row):\n                                    amount = row[amount_col_idx]\n                                    if amount and str(amount).strip():\n                                        try:\n                                            if float(amount) > 0:\n                                                payment_count += 1\n                                        except ValueError as e:\n                                            logger.warning(f\"Skipping non-numeric amount '{amount}' for house {house_number} in {reason}: {e}\")\n                                            pass\n                            \n                            if payment_count > 0:\n                                house_payments[house_number] += payment_count\n            except Exception as e:\n                logger.error(f\"Error reading houses from {reason}: {e}\")\n\n        if not house_payments:\n            await query.message.reply_text(\"üì≠ No houses found.\")\n            return\n\n        # Sort by house number\n        sorted_houses = sorted(house_payments.items())\n\n        # Create buttons (max 5 per row)\n        keyboard = []\n        row = []\n        for house, count in sorted_houses:\n            row.append(\n                InlineKeyboardButton(f\"üè† {house} ({count})\",\n                                     callback_data=f\"house_{house}\"))\n            if len(row) == 3:\n                keyboard.append(row)\n                row = []\n        if row:\n            keyboard.append(row)\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\n        await query.message.reply_text(\n            f\"üìã **All Houses ({len(house_payments)} total)**\\n\\n\"\n            f\"Click a house to see its payment history:\",\n            reply_markup=reply_markup,\n            parse_mode='Markdown')\n\n    except Exception as e:\n        logger.error(f\"Error in show_all_houses: {e}\")\n        error_msg = await query.message.reply_text(f\"‚ùå Error: {e}\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n\n\nasync def show_house_payments(query, house_number, group_id):\n    \"\"\"Show all payments for a specific house\"\"\"\n    try:\n        logger.info(f\"üîç Searching for house {house_number} in group {group_id}\")\n        sheets = setup_sheets(group_id)\n        \n        house_data = []\n\n        for reason in PAYMENT_REASONS.keys():\n            try:\n                sheet = sheets.get(reason) if sheets else None\n                if not sheet:\n                    continue\n\n                values = sheet.get_all_values()\n                # Skip 2 header rows, data starts at row 3 (index 2)\n                # Last row is TOTALS, so skip it too\n                for i in range(2, len(values) - 1):\n                    row = values[i]\n                    # House number is in column B (index 1) - trim whitespace for comparison\n                    if len(row) > 1 and row[1].strip() == house_number.strip():\n                        # For each payment found, search all month columns\n                        # Structure: No (A=0), H.No (B=1), Name (C=2), then 2 cols per month\n                        house_name = row[2] if len(row) > 2 else ''\n                        \n                        # Check each month's Amount column for a payment\n                        for month_idx, month in enumerate(ETHIOPIAN_MONTHS):\n                            amount_col_idx = 3 + (month_idx * 2)  # Amount column\n                            ftno_col_idx = amount_col_idx + 1     # FT No column\n                            \n                            if len(row) > amount_col_idx:\n                                amount = row[amount_col_idx]\n                                txid = row[ftno_col_idx] if len(row) > ftno_col_idx else ''\n                                \n                                # Only add if there's an amount\n                                if amount and amount.strip():\n                                    try:\n                                        # Try to convert to float to validate it's a number\n                                        amount_value = float(amount)\n                                        house_data.append({\n                                            'name': house_name,\n                                            'amount': str(amount_value),\n                                            'month': month,\n                                            'txid': txid,\n                                            'date': '',  # Not stored in current format\n                                            'recorded': '',  # Not stored in current format\n                                            'type': reason\n                                        })\n                                    except ValueError as e:\n                                        # Log the error for debugging but continue\n                                        logger.warning(f\"Skipping non-numeric amount '{amount}' for house {house_number} in {reason}/{month}: {e}\")\n                                        pass\n            except:\n                pass\n\n        if not house_data:\n            logger.warning(f\"üì≠ No payments found for house {house_number} in group {group_id}\")\n            await query.message.reply_text(\n                f\"üì≠ No payments found for house {house_number}.\")\n            return\n        \n        logger.info(f\"‚úÖ Found {len(house_data)} payments for house {house_number}\")\n\n        # Sort by date\n        house_data.sort(key=lambda x: x.get('recorded', ''), reverse=True)\n\n        # Get house name from first payment\n        house_name = house_data[0]['name'] if house_data else \"Unknown\"\n\n        total = sum(\n            float(p['amount']) if p['amount'] else 0 for p in house_data)\n\n        message = f\"üè† **House {house_number}**\\n\"\n        message += f\"üë§ {house_name}\\n\"\n        message += f\"üí∞ Total: {total:,.2f} birr\\n\"\n        message += f\"üìä {len(house_data)} payments\\n\\n\"\n        message += \"**Payment History:**\\n\\n\"\n\n        for i, p in enumerate(house_data, 1):\n            reason_display = PAYMENT_REASONS_AMHARIC.get(p['type'], p['type'].capitalize())\n            month_display = ETHIOPIAN_MONTHS_AMHARIC.get(p['month'], p['month'])\n            message += (f\"{i}. {reason_display}\\n\"\n                        f\"   üí∞ {p['amount']} birr | üìÜ {month_display}\\n\"\n                        f\"   üîñ {p['txid']}\\n\\n\")\n\n            # Split long messages\n            if len(message) > 3500:\n                await query.message.reply_text(message, parse_mode='Markdown')\n                message = \"\"\n\n        if message:\n            await query.message.reply_text(message, parse_mode='Markdown')\n\n    except Exception as e:\n        logger.error(f\"Error in show_house_payments: {e}\")\n        error_msg = await query.message.reply_text(f\"‚ùå Error: {e}\")\n        asyncio.create_task(delete_message_after(error_msg, 600))\n\n\n# ========== START ==========\ndef main():\n    logger.info(\"=\" * 60)\n    logger.info(\"VERSION 20 - MESSAGE DELETION DETECTION + DM + EXCEL + HISTORY\")\n    logger.info(\"‚úì Message deletion detection - abort if user deletes during 30s buffer\")\n    logger.info(\"‚úì DM functionality - /start command works in private messages\")\n    logger.info(\"‚úì Excel download for admins - download payment data as Excel file\")\n    logger.info(\"‚úì Payment history view - button to show house payment history in Amharic\")\n    logger.info(\"‚úì Fixed '·ã®·ãâ·àÉ' water keyword detection (Unicode character variant)\")\n    logger.info(\"‚úì 60-second timeout for edits (30s for normal)\")\n    logger.info(\"=\" * 60)\n\n    application = Application.builder().token(BOT_TOKEN).build()\n\n    # Add command handlers\n    application.add_handler(CommandHandler(\"start\", handle_start_command))\n    application.add_handler(CommandHandler(\"edit\", handle_edit_command))\n    application.add_handler(CommandHandler(\"myid\", handle_myid_command))\n    application.add_handler(CommandHandler(\"admin\", handle_admin_command))\n\n    # Add button click handlers\n    application.add_handler(\n        CallbackQueryHandler(handle_edit_button, pattern=\"^edit_\"))\n    application.add_handler(\n        CallbackQueryHandler(handle_history_button, pattern=\"^history_\"))\n    application.add_handler(\n        CallbackQueryHandler(handle_admin_callbacks, pattern=\"^admin_\"))\n    application.add_handler(\n        CallbackQueryHandler(handle_admin_callbacks, pattern=\"^select_group_\"))\n    application.add_handler(\n        CallbackQueryHandler(handle_admin_callbacks, pattern=\"^house_\"))\n    application.add_handler(\n        CallbackQueryHandler(handle_admin_callbacks, pattern=\"^role_\"))\n    application.add_handler(\n        CallbackQueryHandler(handle_admin_callbacks, pattern=\"^back_to_start$\"))\n\n    # Add message handler (for all non-command messages)\n    application.add_handler(\n        MessageHandler((filters.TEXT | filters.CAPTION | filters.PHOTO)\n                       & ~filters.COMMAND, handle_message))\n\n    logger.info(\"‚úÖ Ready!\")\n    # Log admin counts per group\n    for chat_id, config in GROUP_CONFIGS.items():\n        admin_count = len(config.get('admin_user_ids', []))\n        group_name = config.get('name', f'Group {chat_id}')\n        logger.info(f\"üìä {group_name}: {admin_count} admin(s)\")\n    application.run_polling(allowed_updates=Update.ALL_TYPES)\n\n\nif __name__ == \"__main__\":\n    main()\n","path":null,"size_bytes":166815,"size_tokens":null},"index.js":{"content":"import { Telegraf } from 'telegraf';\nimport { message } from 'telegraf/filters';\nimport dotenv from 'dotenv';\nimport { performOCR } from './services/ocr.js';\nimport { saveToSheet, checkDuplicateTransaction } from './services/sheets.js';\nimport { extractPaymentData } from './services/extraction.js';\nimport { loadConfig } from './config/index.js';\n\ndotenv.config();\n\nconst bot = new Telegraf(process.env.TELEGRAM_BOT_TOKEN);\n\n// Message buffer for collecting multiple messages from same user\nconst userMessageBuffers = new Map();\nconst userBufferTimers = new Map();\n\nconst MESSAGE_BUFFER_DELAY = 30000; // 30 seconds\nconst EDIT_MODE_DELAY = 60000; // 60 seconds\n\n// Load configuration\nconst config = await loadConfig();\n\nconsole.log('‚úÖ Bot starting...');\nconsole.log(`üìä Loaded ${config.groups.length} group(s)`);\n\n// Helper: Buffer messages from user\nfunction bufferMessage(ctx, messageData) {\n  const userId = ctx.from.id;\n  const chatId = ctx.chat.id;\n  const bufferKey = `${chatId}:${userId}`;\n\n  if (!userMessageBuffers.has(bufferKey)) {\n    userMessageBuffers.set(bufferKey, []);\n  }\n\n  userMessageBuffers.get(bufferKey).push(messageData);\n  console.log(`üì• Buffered message from user ${userId} in chat ${chatId} (total: ${userMessageBuffers.get(bufferKey).length})`);\n\n  // Reset timer\n  if (userBufferTimers.has(bufferKey)) {\n    clearTimeout(userBufferTimers.get(bufferKey));\n  }\n\n  // Set new timer to process buffer\n  const timer = setTimeout(() => processBuffer(ctx, chatId, userId), MESSAGE_BUFFER_DELAY);\n  userBufferTimers.set(bufferKey, timer);\n}\n\n// Process buffered messages\nasync function processBuffer(ctx, chatId, userId) {\n  const bufferKey = `${chatId}:${userId}`;\n  const messages = userMessageBuffers.get(bufferKey);\n\n  if (!messages || messages.length === 0) {\n    return;\n  }\n\n  console.log(`üîÑ Processing ${messages.length} buffered messages from user ${userId}`);\n\n  // Separate OCR text from user-typed text\n  const ocrTexts = [];\n  const userTexts = [];\n  const captions = [];\n\n  for (const msg of messages) {\n    if (msg.isOCR) {\n      ocrTexts.push(msg.text);\n    } else if (msg.text) {\n      userTexts.push(msg.text);\n    }\n    if (msg.caption) {\n      captions.push(msg.caption);\n    }\n  }\n\n  const allUserText = userTexts.join(' ');\n  const allOCRText = ocrTexts.join('\\n');\n  const allCaptions = captions.join(' ');\n  const combinedText = allUserText + '\\n' + allOCRText;\n\n  console.log(`User text: ${allUserText.length} chars, OCR: ${allOCRText.length} chars`);\n\n  try {\n    // Extract payment data\n    const data = extractPaymentData(combinedText, allUserText, allCaptions, chatId, config);\n\n    console.log(`Extracted: House=${data.houseNumber}, Amount=${data.amount}, Month=${data.month}`);\n\n    // Check for duplicate transaction ID\n    if (data.transactionId) {\n      const isDuplicate = await checkDuplicateTransaction(data.transactionId, chatId, config);\n      if (isDuplicate) {\n        await ctx.reply(\n          `‚ö†Ô∏è ·ã≠·àÖ ·ã∞·à®·à∞·äù ·ä®·ãö·àÖ ·â†·çä·âµ ·â∞·àç·ä≥·àç ·ä•·äì ·â∞·àò·ãù·åç·âß·àç\\n\\n` +\n          `This receipt has been sent before and recorded.\\n\\n` +\n          `üîñ Transaction ID: ${data.transactionId}`\n        );\n        return;\n      }\n    }\n\n    // Validate beneficiary if configured\n    if (data.beneficiary && config.authorizedBeneficiaries) {\n      const isValid = validateBeneficiary(data.beneficiary, config.authorizedBeneficiaries);\n      if (!isValid) {\n        await ctx.reply(`‚ùå Invalid beneficiary: ${data.beneficiary}`);\n        return;\n      }\n    }\n\n    // Save to Google Sheets\n    await saveToSheet(data, chatId, config);\n\n    // Send success reaction and message\n    await ctx.react('üëç');\n    await ctx.reply(\n      `‚úÖ ·â∞·àò·ãù·åç·âß·àç!\\n\\n` +\n      `üè† ·â§·âµ: ${data.houseNumber}\\n` +\n      `üí∞ ·àò·å†·äï: ${data.amount} ·â•·à≠\\n` +\n      `üìÖ ·ãà·à≠: ${data.month}\\n` +\n      `‚úÖ ·àù·ä≠·äï·ã´·âµ: ${data.reason}`\n    );\n\n  } catch (error) {\n    console.error('Error processing messages:', error);\n    await ctx.reply(`‚ùå Error: ${error.message}`);\n  } finally {\n    // Clean up buffer\n    userMessageBuffers.delete(bufferKey);\n    userBufferTimers.delete(bufferKey);\n  }\n}\n\n// Handle text messages\nbot.on(message('text'), async (ctx) => {\n  const chatId = ctx.chat.id;\n  const threadId = ctx.message.message_thread_id;\n\n  // Find group configuration\n  const groupConfig = config.groups.find(g => g.chatId === chatId);\n  if (!groupConfig) {\n    console.log(`‚è≠Ô∏è Ignoring message from unconfigured group: ${chatId}`);\n    return;\n  }\n\n  // Check if message is in correct topic/thread\n  if (groupConfig.topicId && threadId !== groupConfig.topicId) {\n    console.log(`‚è≠Ô∏è Ignoring message from wrong topic. Expected: ${groupConfig.topicId}, Got: ${threadId}`);\n    return;\n  }\n\n  // Buffer the text message\n  bufferMessage(ctx, {\n    text: ctx.message.text,\n    isOCR: false,\n    caption: null\n  });\n});\n\n// Handle photo messages\nbot.on(message('photo'), async (ctx) => {\n  const chatId = ctx.chat.id;\n  const threadId = ctx.message.message_thread_id;\n\n  // Find group configuration\n  const groupConfig = config.groups.find(g => g.chatId === chatId);\n  if (!groupConfig) {\n    return;\n  }\n\n  // Check topic\n  if (groupConfig.topicId && threadId !== groupConfig.topicId) {\n    return;\n  }\n\n  console.log(`üì∏ Processing image from user ${ctx.from.id}...`);\n\n  try {\n    // Get the largest photo\n    const photo = ctx.message.photo[ctx.message.photo.length - 1];\n    const fileLink = await ctx.telegram.getFileLink(photo.file_id);\n\n    console.log(`üì∏ Running OCR...`);\n    const ocrText = await performOCR(fileLink.href);\n    console.log(`‚úì OCR done: ${ocrText.length} chars`);\n\n    // Buffer the OCR result\n    bufferMessage(ctx, {\n      text: ocrText,\n      isOCR: true,\n      caption: ctx.message.caption || null\n    });\n\n  } catch (error) {\n    console.error('OCR Error:', error);\n    await ctx.reply(`‚ùå OCR failed: ${error.message}`);\n  }\n});\n\n// Helper: Validate beneficiary\nfunction validateBeneficiary(beneficiary, authorizedList) {\n  const beneficiaryTokens = beneficiary.toUpperCase().split(/\\s+/);\n  const authorizedTokens = authorizedList.flatMap(name => \n    name.toUpperCase().split(/\\s+/)\n  );\n\n  return beneficiaryTokens.some(token => authorizedTokens.includes(token));\n}\n\n// Error handling\nbot.catch((err, ctx) => {\n  console.error(`Error for ${ctx.updateType}:`, err);\n});\n\n// Start bot\nbot.launch().then(() => {\n  console.log('‚úÖ Bot is running!');\n});\n\n// Enable graceful stop\nprocess.once('SIGINT', () => bot.stop('SIGINT'));\nprocess.once('SIGTERM', () => bot.stop('SIGTERM'));\n","path":null,"size_bytes":6626,"size_tokens":null},"main.py":{"content":"\"\"\"\nTelegram Payment Receipt Bot - Main Entry Point\n\nThis bot processes payment receipts for an apartment complex, extracting transaction \ndetails and storing them in Google Sheets.\n\"\"\"\n\nif __name__ == \"__main__\":\n    from better1 import main\n    main()\n","path":null,"size_bytes":254,"size_tokens":null}},"version":2}